Index: ubuntu/plugins/expo/expo.xml.in
===================================================================
--- ubuntu.orig/plugins/expo/expo.xml.in	2012-09-12 22:20:42.944758828 +0800
+++ ubuntu/plugins/expo/expo.xml.in	2012-09-12 22:20:43.240760303 +0800
@@ -17,6 +17,7 @@
 		<plugin>wobbly</plugin>
 		<plugin>animation</plugin>
 		<plugin>wallpaper</plugin>
+		<plugin>imgpng</plugin>
 	    </relation>
 	</deps>
 	<options>
@@ -25,7 +26,7 @@
 		<option name="expo_key" type="key">
 		    <_short>Expo key</_short>
 		    <_long>Engage wall expo mode key binding</_long>
-		    <default>&lt;Super&gt;e</default>
+		    <default>&lt;Super&gt;s</default>
 		</option>
 		<option name="expo_button" type="button">
 		    <_short>Expo button</_short>
@@ -35,8 +36,6 @@
 		<option name="expo_edge" type="edge">
 		    <_short>Expo edge</_short>
 		    <_long>Engage wall expo mode edge binding</_long>
-		    <default>
-		    </default>
 		</option>
 		<option name="double_click_time" type="int">
 		    <_short>Double click time</_short>
@@ -79,7 +78,7 @@
 		<option name="zoom_time" type="float">
 		    <_short>Zoom time</_short>
 		    <_long>Duration of the zoomout animation</_long>
-		    <default>0.5</default>
+		    <default>0.3</default>
 		    <min>0.1</min>
 		    <max>5.0</max>
 		    <precision>0.1</precision>
@@ -130,10 +129,24 @@
 			<_name>Curve</_name>
 		    </desc>
 		</option>
+		<option name="x_offset" type="int">
+		    <_short>X Space</_short>
+		    <_long> Left Side screen space of expo in pixels</_long>
+		    <min>-1680</min>
+		    <max>1680</max>
+		    <default>64</default>
+                </option>
+		<option name="y_offset" type="int">
+		    <_short>Y Space</_short>
+		    <_long> Top Side screen space of expo in pixels</_long>
+		    <min>-100</min>
+		    <max>100</max>
+		    <default>24</default>
+                </option>
 		<option name="distance" type="float">
 		    <_short>Distance</_short>
 		    <_long>Distance of the expo wall</_long>
-		    <default>0.0</default>
+		    <default>0.005</default>
 		    <min>0.0</min>
 		    <max>1.0</max>
 		    <precision>0.01</precision>
@@ -141,7 +154,7 @@
 		<option name="vp_distance" type="float">
 		    <_short>Viewport distance</_short>
 		    <_long>Distance between viewports</_long>
-		    <default>0.10</default>
+		    <default>0.2</default>
 		    <min>0.0</min>
 		    <max>1.0</max>
 		    <precision>0.01</precision>
@@ -192,7 +205,7 @@
 		    <option name="vp_brightness" type="float">
 			<_short>Brightness</_short>
 			<_long>Inactive viewport brightness.</_long>
-			<default>75.0</default>
+			<default>40.0</default>
 			<min>0.0</min>
 			<max>100.0</max>
 			<precision>0.1</precision>
@@ -200,18 +213,28 @@
 		    <option name="vp_saturation" type="float">
 			<_short>Saturation</_short>
 			<_long>Inactive viewport saturation.</_long>
-			<default>100.0</default>
+			<default>40.0</default>
 			<min>0.0</min>
 			<max>100.0</max>
 			<precision>0.1</precision>
 		    </option>
+		    <option name="selected_color" type="color">
+			<_short>Selected Color</_short>
+			<_long>Color to use when highlighting the selected viewport</_long>
+			<default>
+			    <red>0xfbfb</red>
+			    <green>0x8b8b</green>
+			    <blue>0x0</blue>
+			    <alpha>0xffff</alpha>
+			</default>
+		    </option>
 		</subgroup>
 		<subgroup>
 		    <short>Reflection</short>
 		    <option name="reflection" type="bool">
 			<_short>Reflection</_short>
 			<_long>Show a reflection of the viewports on the ground</_long>
-			<default>true</default>
+			<default>false</default>
 		    </option>
 		    <option name="ground_color1" type="color">
 			<_short>Ground color(near)</_short>
@@ -244,7 +267,7 @@
 		    <option name="scale_factor" type="float">
 			<_short>Reflection Scale</_short>
 			<_long>Scale factor of the expo wall reflection</_long>
-			<default>0.75</default>
+			<default>1.0</default>
 			<min>0.0</min>
 			<max>2.0</max>
 			<precision>0.01</precision>
Index: ubuntu/plugins/expo/src/expo.cpp
===================================================================
--- ubuntu.orig/plugins/expo/src/expo.cpp	2012-09-12 22:09:32.323735000 +0800
+++ ubuntu/plugins/expo/src/expo.cpp	2012-09-12 22:29:50.643474721 +0800
@@ -27,6 +27,8 @@
 
 #include "expo.h"
 #include "click-threshold.h"
+#include "wall-offset.h"
+#include "windows-on-viewport.h"
 #include <math.h>
 #ifndef USE_GLES
 #include <GL/glu.h>
@@ -73,11 +75,10 @@
 
     if (dndState == DnDDuring || dndState == DnDStart)
     {
-	if (dndWindow)
+	if (dndWindows.size ())
 	    finishWindowMovement ();
 
 	dndState  = DnDNone;
-	dndWindow = NULL;
 
 	action->setState (action->state () & CompAction::StateInitButton);
 	cScreen->damageScreen ();
@@ -113,7 +114,6 @@
 	clickTime   = 0;
 
 	dndState  = DnDNone;
-	dndWindow = NULL;
 
 	selectedVp = screen->vp ();
 	lastSelectedVp = screen->vp ();
@@ -156,8 +156,8 @@
     else
 	vpUpdateMode = VPUpdateMouseOver;
 
-    dndState  = DnDNone;
-    dndWindow = NULL;
+    dndState = DnDNone;
+    dndWindows.clear ();
 
     screen->removeAction (&optionGetDndButton ());
     screen->removeAction (&optionGetExitButton ());
@@ -202,6 +202,8 @@
     if (!expoMode)
 	return false;
 
+    lastSelectedVp = selectedVp;
+
     newX = selectedVp.x () + 1;
     newY = selectedVp.y ();
 
@@ -225,7 +227,7 @@
 		    CompAction::State   state,
 		    CompOption::Vector& options)
 {
-    int newX, newY;
+    unsigned int newX, newY;
     Window       xid = CompOption::getIntOptionNamed (options, "root", 0);
     if (xid != screen->root ())
 	return false;
@@ -272,53 +274,39 @@
 void
 ExpoScreen::finishWindowMovement ()
 {
-    dndWindow->syncPosition ();
-    dndWindow->ungrabNotify ();
-
-    screen->moveViewport (screen->vp ().x () - selectedVp.x (),
-			  screen->vp ().y () - selectedVp.y (), true);
-
-    /* update saved window attributes in case we moved the
-       window to a new viewport */
-    if (dndWindow->saveMask () & CWX)
-    {
-	dndWindow->saveWc ().x = dndWindow->saveWc ().x % screen->width ();
-	if (dndWindow->saveWc ().x < 0)
-	    dndWindow->saveWc ().x += screen->width ();
-    }
-    if (dndWindow->saveMask () & CWY)
+    foreach (CompWindow *dndWindow, dndWindows)
     {
-	dndWindow->saveWc ().y = dndWindow->saveWc ().y % screen->height ();
-	if (dndWindow->saveWc ().y < 0)
-	    dndWindow->saveWc ().y += screen->height ();
-    }
-
-    /* update window attibutes to make sure a moved maximized window
-       is properly snapped to the work area */
-    if (dndWindow->state () & MAXIMIZE_STATE)
-	dndWindow->updateAttributes (CompStackingUpdateModeNone);
-
-#if 0 /* FIXME: obsolete in the meantime? */
-    {
-	int lastOutput;
-	int centerX, centerY;
+	if (dndWindow->grabbed ())
+	{
+	    dndWindow->syncPosition ();
+	    dndWindow->ungrabNotify ();
 
-	/* make sure we snap to the correct output */
-	lastOutput = s->currentOutputDev;
-	centerX = (WIN_X (w) + WIN_W (w) / 2) % s->width;
-	if (centerX < 0)
-	    centerX += s->width;
-	centerY = (WIN_Y (w) + WIN_H (w) / 2) % s->height;
-	if (centerY < 0)
-	    centerY += s->height;
+	    screen->updateGrab (grabIndex, None);
 
-	s->currentOutputDev = outputDeviceForPoint (s, centerX, centerY);
+	    screen->moveViewport (screen->vp ().x () - selectedVp.x (),
+				  screen->vp ().y () - selectedVp.y (), true);
 
-	updateWindowAttributes (w, CompStackingUpdateModeNone);
+	    /* update saved window attributes in case we moved the
+    window to a new viewport */
+	    if (dndWindow->saveMask () & CWX)
+	    {
+		dndWindow->saveWc ().x = dndWindow->saveWc ().x % screen->width ();
+		if (dndWindow->saveWc ().x < 0)
+		    dndWindow->saveWc ().x += screen->width ();
+	    }
+	    if (dndWindow->saveMask () & CWY)
+	    {
+		dndWindow->saveWc ().y = dndWindow->saveWc ().y % screen->height ();
+		if (dndWindow->saveWc ().y < 0)
+		    dndWindow->saveWc ().y += screen->height ();
+	    }
 
-	s->currentOutputDev = lastOutput;
+	    /* update window attibutes to make sure a moved maximized window
+	   is properly snapped to the work area */
+	    if (dndWindow->state () & MAXIMIZE_STATE)
+		dndWindow->updateAttributes (CompStackingUpdateModeNone);
+	}
     }
-#endif
 }
 
 void
@@ -402,6 +390,80 @@
     screen->handleEvent (event);
 }
 
+bool
+ExpoWindow::dragged () const
+{
+    ExpoScreen *es = ExpoScreen::get (screen);
+
+    return std::find (es->dndWindows.begin (), es->dndWindows.end (), window) != es->dndWindows.end ();
+}
+
+const compiz::window::Geometry &
+ExpoWindow::absoluteGeometry () const
+{
+    const compiz::window::Geometry &relativeGeometry (window->geometry ());
+    mAbsoluteGeometry.set ((screen->vp ().x () * screen->width ()) + relativeGeometry.x (),
+			   (screen->vp ().y () * screen->height ()) + relativeGeometry.y (),
+			   relativeGeometry.width (),
+			   relativeGeometry.height (),
+			   relativeGeometry.border ());
+
+    return mAbsoluteGeometry;
+}
+
+bool
+ExpoWindow::isDesktopOrDock () const
+{
+    return window->type () == CompWindowTypeDesktopMask ||
+	   window->type () == CompWindowTypeDockMask;
+}
+
+namespace cei = compiz::expo::impl;
+
+cei::CompizClientListGenerator::CompizClientListGenerator (CompScreen *screen) :
+    mScreen (screen),
+    mClientList (&mScreen->clientList (true)),
+    mClientListIterator (mClientList->begin ())
+{
+}
+
+compiz::expo::ViewportMemberWindow *
+cei::CompizClientListGenerator::nextClient ()
+{
+    if (mClientListIterator == mClientList->end ())
+	return NULL;
+
+    compiz::expo::ViewportMemberWindow *vpMemberWindow = ExpoWindow::get (*mClientListIterator);
+
+    ++mClientListIterator;
+
+    return vpMemberWindow;
+}
+
+bool
+ExpoScreen::windowsOnVp (compiz::expo::ClientListGenerator &clientList,
+			 CompPoint                         &p,
+			 const CompPoint                   &unprojectedCursor,
+			 const CompSize                    &screenSize,
+			 CompScreen                        *screen)
+{
+    return false;
+}
+
+namespace
+{
+    void fillInNewViewportActivityData (unsigned int vpCount,
+					std::vector <float> &vpActivity)
+    {
+	if (vpActivity.size () < vpCount)
+	{
+	    vpActivity.resize (vpCount);
+	    foreach (float& activity, vpActivity)
+		activity = 1.0f;
+	}
+    }
+}
+
 void
 ExpoScreen::preparePaint (int msSinceLastPaint)
 {
@@ -412,33 +474,43 @@
     else
 	expoCam = MAX (0.0, expoCam - val);
 
-    if (expoCam)
+    if (dndState == DnDDuring)
     {
-	unsigned int i, j, vp;
-	unsigned int vpCount = screen->vpSize ().width () *
-	                       screen->vpSize ().height ();
+	foreach (CompWindow *w, dndWindows)
+	    ExpoWindow::get (w)->dndOpacity = MIN (1.0, ExpoWindow::get (w)->dndOpacity + val);
+    }
+    else if (dndState == DnDNone)
+    {
+	CompWindowList::iterator it = dndWindows.begin ();
 
-	if (vpActivity.size () < vpCount)
+	while (it != dndWindows.end ())
 	{
-	    vpActivity.resize (vpCount);
-	    foreach (float& activity, vpActivity)
-		activity = 1.0f;
-	}
+	    ExpoWindow::get ((*it))->dndOpacity = MAX (0.0, ExpoWindow::get ((*it))->dndOpacity - val);
 
-	for (i = 0; i < (unsigned int) screen->vpSize ().width (); i++)
-	{
-	    for (j = 0; j < (unsigned int) screen->vpSize ().height (); j++)
+	    if (ExpoWindow::get ((*it))->dndOpacity <= 0.0f)
 	    {
-		vp = (j * screen->vpSize ().width ()) + i;
-
-		if (CompPoint (i, j) == selectedVp)
-		    vpActivity[vp] = MIN (1.0, vpActivity[vp] + val);
-		else
-		    vpActivity[vp] = MAX (0.0, vpActivity[vp] - val);
+		dndWindows.erase (it);
+		it = dndWindows.begin ();
 	    }
+	    else
+		it++;
 	}
+    }
 
-	for (i = 0; i < 360; i++)
+    if (expoCam)
+    {
+	unsigned int vpCount = compiz::expo::countViewports (screen->vpSize ());
+
+	fillInNewViewportActivityData (vpCount, vpActivity);
+	compiz::expo::fillInNewViewportActiveData (vpCount, vpActive);
+
+	for (unsigned int i = 0; i < vpCount; i++)
+	    if (vpActive[i])
+		vpActivity[i] = MIN (1.0, vpActivity[i] + val);
+	    else
+		vpActivity[i] = MAX (0.0, vpActivity[i] - val);
+
+	for (int i = 0; i < 360; i++)
 	{
 	    float fi = (float) i;
 
@@ -509,6 +581,31 @@
     cScreen->paint (outputs, mask);
 }
 
+namespace
+{
+    void updateViewportActiveStates (CompScreen *screen)
+    {
+	ExpoScreen *es = ExpoScreen::get (screen);
+
+	unsigned int vpCount = compiz::expo::countViewports (screen->vpSize ());
+	fillInNewViewportActivityData (vpCount, es->vpActivity);
+
+	for (int i = 0; i < screen->vpSize ().width (); i++)
+	{
+	    for (int j = 0; j < screen->vpSize ().height (); j++)
+	    {
+		compiz::expo::impl::CompizClientListGenerator clientList (screen);
+
+		compiz::expo::activeViewportsForMembers (clientList,
+							 es->newCursor,
+							 screen->vpSize (),
+							 *screen,
+							 es->vpActive);
+	    }
+	}
+    }
+}
+
 void
 ExpoScreen::donePaint ()
 {
@@ -539,6 +636,11 @@
 	foreach (float& vp, vpActivity)
 	    if (vp != 0.0 && vp != 1.0)
 		cScreen->damageScreen ();
+
+	foreach (CompWindow *w, dndWindows)
+	    if (ExpoWindow::get (w)->dndOpacity != 0.0f &&
+		ExpoWindow::get (w)->dndOpacity != 1.0f)
+		cScreen->damageScreen ();
     }
 
     if (grabIndex && expoCam <= 0.0f && !expoMode)
@@ -553,10 +655,25 @@
     switch (dndState) {
     case DnDDuring:
 	{
-	    if (dndWindow)
-		dndWindow->move (newCursor.x () - prevCursor.x (),
-				 newCursor.y () - prevCursor.y (),
-				 optionGetExpoImmediateMove ());
+	    if (dndWindows.size ())
+	    {
+		foreach (CompWindow *dndWindow, dndWindows)
+		{
+		    if (dndWindow->grabbed ())
+		    {
+			ExpoWindow *ew = ExpoWindow::get (dndWindow);
+
+			/* No need to update twice */
+			dndWindow->moveNotifySetEnabled (ew, false);
+			dndWindow->move (newCursor.x () - prevCursor.x (),
+					 newCursor.y () - prevCursor.y (),
+					 optionGetExpoImmediateMove ());
+			dndWindow->moveNotifySetEnabled (ew, true);
+
+			updateViewportActiveStates (screen);
+		    }
+		}
+	    }
 
 	    prevCursor = newCursor;
 	    cScreen->damageScreen ();
@@ -621,13 +738,13 @@
 		    break;
 
 		dndState  = DnDDuring;
-		dndWindow = w;
+		dndWindows.push_back (w);
 
 		w->grabNotify (nx, ny, 0,
 			       CompWindowGrabMoveMask |
 			       CompWindowGrabButtonMask);
 
-		screen->updateGrab (grabIndex, dragCursor);
+		screen->updateGrab (grabIndex, mMoveCursor);
 
 		w->raise ();
 		w->moveInputFocusTo ();
@@ -762,6 +879,124 @@
 }
 
 void
+ExpoScreen::paintViewport (const GLScreenPaintAttrib& attrib,
+			   const GLMatrix&            transform,
+			   const CompRegion&          region,
+			   CompOutput                 *output,
+			   unsigned int               mask,
+			   CompPoint                  vpPos,
+			   GLVector                   &vpCamPos,
+			   bool                       reflection)
+{
+    GLMatrix     sTransform (transform);
+    GLMatrix     sTransform2, sTransform3;
+    float        sx = (float) screen->width () / output->width ();
+    float        sy = (float) screen->height () / output->height ();
+    float        vpp;
+    float        progress = sigmoidProgress (expoCam);
+    unsigned int vp;
+    CompPoint    vpSize (screen->vpSize ().width (), screen->vpSize ().height ());
+
+    const float gapY = optionGetVpDistance () * 0.1f * expoCam;
+    const float gapX = optionGetVpDistance () * 0.1f * screen->height () /
+		       screen->width () * expoCam;
+
+    /* not sure this will work with different resolutions */
+    sTransform.translate (0.0, MAX (0, vpPos.y ()) * -(sy + gapY), 0.0f);
+
+    sTransform2 = sTransform;
+
+    /* not sure this will work with different resolutions */
+    if (optionGetDeform () != DeformCurve)
+	sTransform2.translate (MAX (0, vpPos.x ()) * (sx + gapX), 0.0f, 0.0);
+
+
+    if (optionGetExpoAnimation () == ExpoAnimationVortex)
+	sTransform2.rotate (360 * expoCam,
+			    0.0f, 1.0f, 2.0f * expoCam);
+
+    sTransform3 = sTransform2;
+
+    sTransform3.translate (output->x () / output->width (),
+			   -output->y () / output->height (), 0.0);
+
+    cScreen->setWindowPaintOffset ((screen->vp ().x () - vpPos.x ()) *
+				   screen->width (),
+				   (screen->vp ().y () - vpPos.y ()) *
+				   screen->height ());
+
+    vp = (vpPos.y () * vpSize.x ()) + vpPos.x ();
+
+    vpp = (expoCam * vpActivity[vp]) + (1 - expoCam);
+    vpp = sigmoidProgress (vpp);
+
+    vpBrightness = vpp + ((1.0 - vpp) *
+			  optionGetVpBrightness () / 100.0);
+    vpSaturation = vpp + ((1.0 - vpp) *
+			  optionGetVpSaturation () / 100.0);
+
+    paintingVp = vpPos;
+
+    if (optionGetDeform () == DeformCurve)
+    {
+	float rotateX;
+
+	sTransform3.translate (-vpCamPos[GLVector::x], 0.0f,
+			       curveDistance - DEFAULT_Z_CAMERA);
+
+	rotateX = -vpPos.x () + interpolate (((float) vpSize.x () / 2.0) - 0.5,
+				    screen->vp ().x (), progress);
+
+	sTransform3.rotate (curveAngle * rotateX, 0.0, 1.0, 0.0);
+
+	sTransform3.translate (vpCamPos[GLVector::x], 0.0f,
+			       DEFAULT_Z_CAMERA - curveDistance);
+    }
+
+    if (paintingDndWindow)
+	cScreen->getWindowPaintListSetEnabled (this, true);
+    gScreen->glPaintTransformedOutput (attrib, sTransform3,
+				       screen->region (), output,
+				       mask);
+
+    if (paintingDndWindow)
+	cScreen->getWindowPaintListSetEnabled (this, false);
+
+    if (!reflection && !paintingDndWindow)
+    {
+	int cursor[2] = { pointerX, pointerY };
+
+	invertTransformedVertex (attrib, sTransform3,
+				 output, cursor);
+
+	if ((cursor[0] > 0) && (cursor[0] < (int) screen->width ()) &&
+		(cursor[1] > 0) && (cursor[1] < (int) screen->height ()))
+	{
+	    newCursor.setX (vpPos.x () * screen->width () + cursor[0]);
+	    newCursor.setY (vpPos.y () * screen->height () + cursor[1]);
+
+	    if (anyClick || dndState != DnDNone)
+	    {
+		/* Used to save last viewport interaction was in */
+		selectedVp = vpPos;
+		anyClick = false;
+	    }
+	}
+    }
+
+    /* Calculate the current viewport size */
+    int tl[2] = { 0, 0 };
+    int br[2] = { screen->width (), screen->height () };
+
+    invertTransformedVertex (attrib, sTransform3, output, tl);
+    invertTransformedVertex (attrib, sTransform3, output, br);
+
+    viewport_size = CompSize (br[0] - tl[0], br[1] - tl[1]);
+
+    cScreen->setWindowPaintOffset (0, 0);
+}
+
+void
 ExpoScreen::paintWall (const GLScreenPaintAttrib& attrib,
 		       const GLMatrix&            transform,
 		       const CompRegion&          region,
@@ -772,13 +1007,11 @@
     GLfloat vertexData[12];
     GLushort colorData[16];
     GLMatrix sTransformW, sTransform (transform);
-    int      i, j, vp;
     GLenum   oldFilter = gScreen->textureFilter ();
-
-    float     sx = (float) screen->width () / output->width ();
-    float     sy = (float) screen->height () / output->height ();
+    float        sx = (float) screen->width () / output->width ();
+    float        sy = (float) screen->height () / output->height ();
     float     biasZ;
-    float     oScale, rotation = 0.0f, progress, vpp;
+    float     oScale, rotation = 0.0f, progress;
     float     aspectX = 1.0f, aspectY = 1.0f;
     GLVector  cam;
     CompPoint vpSize (screen->vpSize ().width (), screen->vpSize ().height ());
@@ -910,9 +1143,24 @@
     sTransform.rotate (rotation, 0.0f, 1.0f, 0.0f);
     sTransform.scale (aspectX, aspectY, 1.0);
 
+    CompPoint offsetInScreenCoords (optionGetXOffset (),
+				    optionGetYOffset ());
+    float     offsetInWorldCoordX, offsetInWorldCoordY, worldScaleFactorX, worldScaleFactorY;
+
+    compiz::expo::calculateWallOffset (*output,
+				       offsetInScreenCoords,
+				       vpSize,
+				       *screen,
+				       offsetInWorldCoordX,
+				       offsetInWorldCoordY,
+				       worldScaleFactorX,
+				       worldScaleFactorY,
+				       sigmoidProgress (expoCam));
+
     /* translate expo to center */
-    sTransform.translate (vpSize.x () * sx * -0.5,
-			  vpSize.y () * sy * 0.5, 0.0f);
+    sTransform.translate (vpSize.x () * sx * -0.5 + offsetInWorldCoordX,
+			  vpSize.y () * sy * 0.5 - offsetInWorldCoordY, 0.0f);
+    sTransform.scale (worldScaleFactorX, worldScaleFactorY, 1.0f);
 
     if (optionGetDeform () == DeformCurve)
 	sTransform.translate ((vpSize.x () - 1) * sx * 0.5, 0.0, 0.0);
@@ -936,90 +1184,29 @@
 
     expoActive = true;
 
-    for (j = 0; j < vpSize.y (); j++)
-    {
-	GLMatrix sTransform2 (sTransform), sTransform3;
-
-	for (i = 0; i < vpSize.x (); i++)
-	{
-	    if (optionGetExpoAnimation () == ExpoAnimationVortex)
-		sTransform2.rotate (360 * expoCam,
-				    0.0f, 1.0f, 2.0f * expoCam);
-
-	    sTransform3 = sTransform2;
-
-	    sTransform3.translate (output->x () / output->width (),
-				   -output->y () / output->height (), 0.0);
-
-	    cScreen->setWindowPaintOffset ((screen->vp ().x () - i) *
-					   screen->width (),
-					   (screen->vp ().y () - j) *
-					   screen->height ());
-
-	    vp = (j * vpSize.x ()) + i;
-
-	    vpp = (expoCam * vpActivity[vp]) + (1 - expoCam);
-	    vpp = sigmoidProgress (vpp);
-
-	    vpBrightness = vpp + ((1.0 - vpp) *
-				  optionGetVpBrightness () / 100.0);
-	    vpSaturation = vpp + ((1.0 - vpp) *
-				  optionGetVpSaturation () / 100.0);
+    for (int j = 0; j < screen->vpSize ().height (); j++)
+	for (int i = 0; i < screen->vpSize().width (); i++)
+	    paintViewport (attrib, sTransform, region, output, mask, CompPoint (i, j), vpCamPos, reflection);
 
-	    paintingVp.set (i, j);
+    paintingDndWindow = true;
 
-	    if (optionGetDeform () == DeformCurve)
-	    {
-		float rotateX;
-
-		sTransform3.translate (-vpCamPos[GLVector::x], 0.0f,
-				       curveDistance - DEFAULT_Z_CAMERA);
-
-		rotateX = -i + interpolate (((float) vpSize.x () / 2.0) - 0.5,
-					    screen->vp ().x (), progress);
-
-		sTransform3.rotate (curveAngle * rotateX, 0.0, 1.0, 0.0);
-
-		sTransform3.translate (vpCamPos[GLVector::x], 0.0f,
-				       DEFAULT_Z_CAMERA - curveDistance);
-	    }
-
-	    gScreen->glPaintTransformedOutput (attrib, sTransform3,
-					       screen->region (), output,
-					       mask);
-
-	    if (!reflection)
-	    {
-		int cursor[2] = { pointerX, pointerY };
+    foreach (CompWindow *dndWindow, dndWindows)
+    {
+	CompPoint vp;
 
-		invertTransformedVertex (attrib, sTransform3,
-					 output, cursor);
+	screen->viewportForGeometry (dndWindow->geometry (), vp);
 
-		if ((cursor[0] > 0) && (cursor[0] < (int) screen->width ()) &&
-		    (cursor[1] > 0) && (cursor[1] < (int) screen->height ()))
-		{
-		    newCursor.setX (i * screen->width () + cursor[0]);
-		    newCursor.setY (j * screen->height () + cursor[1]);
+	while (vp.x () < 0)
+	    vp.setX (screen->vpSize ().width () + vp.x ());
 
-		    if (anyClick || dndState != DnDNone)
-		    {
-			/* Used to save last viewport interaction was in */
-			lastSelectedVp = selectedVp;
-			selectedVp.set (i, j);
-			anyClick = false;
-		    }
-		}
-	    }
+	while (vp.y () < 0)
+	    vp.setY (screen->vpSize ().height () + vp.y ());
 
-	    /* not sure this will work with different resolutions */
-	    if (optionGetDeform () != DeformCurve)
-		sTransform2.translate (sx + gapX, 0.0f, 0.0);
-	}
-
-	/* not sure this will work with different resolutions */
-	sTransform.translate (0.0, -(sy + gapY), 0.0f);
+	paintViewport (attrib, sTransform, infiniteRegion, output, mask, vp, vpCamPos, reflection);
     }
 
+    paintingDndWindow = false;
+
 //    glNormal3f (0.0, 0.0, -1.0);
 
     if (reflection)
@@ -1187,12 +1374,16 @@
 
     expoActive = false;
 
-    cScreen->setWindowPaintOffset (0, 0);
-
     gScreen->glPaintTransformedOutputSetCurrentIndex (glPaintTransformedOutputIndex);
     gScreen->setTextureFilter (oldFilter);
 }
 
+const CompWindowList &
+ExpoScreen::getWindowPaintList ()
+{
+    return dndWindows;
+}
+
 bool
 ExpoScreen::glPaintOutput (const GLScreenPaintAttrib& attrib,
 			   const GLMatrix&            transform,
@@ -1243,10 +1434,15 @@
 
 bool
 ExpoWindow::glDraw (const GLMatrix&     transform,
-                    const GLWindowPaintAttrib &attrib,
+		    const GLWindowPaintAttrib &attrib,
 		    const CompRegion&   region,
 		    unsigned int        mask)
 {
+    GLMatrix wTransform (transform);
+    CompPoint vp;
+
+    screen->viewportForGeometry (window->geometry (), vp);
+
     if (eScreen->expoCam == 0.0f)
 	return gWindow->glDraw (transform, attrib, region, mask);
 
@@ -1275,8 +1471,11 @@
 	    }
 	}
 
-	eAttrib.brightness = attrib.brightness * eScreen->vpBrightness;
-	eAttrib.saturation = attrib.saturation * eScreen->vpSaturation;
+	if ((vp == eScreen->paintingVp || window->onAllViewports ()) && !eScreen->paintingDndWindow)
+	{
+	    eAttrib.brightness = attrib.brightness * eScreen->vpBrightness;
+	    eAttrib.saturation = attrib.saturation * eScreen->vpSaturation;
+	}
     }
     else
     {
@@ -1287,7 +1486,79 @@
 	                              (1 - sigmoidProgress (eScreen->expoCam));
     }
 
-    return gWindow->glDraw (transform, eAttrib, region, mask);
+    bool status = gWindow->glDraw (transform, eAttrib, region, mask);
+
+    if (window->type () & CompWindowTypeDesktopMask)
+    {
+	/* We want to set the geometry of the polka dots to the window
+	 * region */
+	CompRegion reg = CompRegion (0, 0, window->width (), window->height ());
+
+	foreach(GLTexture * tex, eScreen->polkadots_texture)
+	{
+	    GLTexture::MatrixList matl;
+	    GLTexture::Matrix     mat = tex->matrix();
+	    CompRegion            paintRegion(region);
+
+	    float xScale = screen->width () / (float) eScreen->viewport_size.width ();
+	    float yScale = screen->height () / (float) eScreen->viewport_size.height ();
+
+	    mat.xx *= xScale;
+	    mat.yy *= yScale;
+
+	    /* Not sure what this does, but it is necessary
+	     * (adjusts for scale?) */
+	    mat.x0 -= mat.xx * reg.boundingRect().x1();
+	    mat.y0 -= mat.yy * reg.boundingRect().y1();
+
+	    matl.push_back(mat);
+
+	    if (mask & PAINT_WINDOW_TRANSFORMED_MASK)
+		paintRegion = infiniteRegion;
+
+	    /* Now allow plugins to mess with the geometry of our
+	     * dim (so we get a nice render for things like
+	     * wobbly etc etc */
+	    gWindow->vertexBuffer ()->begin ();
+	    gWindow->glAddGeometry (matl, reg, paintRegion);
+	    if (gWindow->vertexBuffer ()->end ())
+	    {
+		unsigned int glDrawTextureIndex = gWindow->glDrawTextureGetCurrentIndex ();
+		eAttrib.opacity = attrib.opacity * (((1.0 - eScreen->vpBrightness) + (1.0 - eScreen->vpSaturation) / 2.0));
+		/* Texture rendering set-up */
+		//eScreen->gScreen->setTexEnvMode(GL_MODULATE);
+		glBlendFunc (GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
+		/* Draw the dim texture with all of it's modified
+		* geometry glory */
+		gWindow->glDrawTextureSetCurrentIndex (MAXSHORT);
+		gWindow->glDrawTexture (tex, transform, eAttrib, mask |
+					PAINT_WINDOW_BLEND_MASK |
+					PAINT_WINDOW_TRANSLUCENT_MASK |
+					PAINT_WINDOW_TRANSFORMED_MASK);
+		gWindow->glDrawTextureSetCurrentIndex (glDrawTextureIndex);
+		/* Texture rendering tear-down */
+		glBlendFunc (GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
+		eScreen->gScreen->setTexEnvMode (GL_REPLACE);
+	    }
+	}
+
+	/* Paint the outline */
+	if (mGlowQuads && eScreen->paintingVp == eScreen->selectedVp)
+	{
+	    if (region.numRects ())
+	    {
+		/* reset geometry and paint */
+		gWindow->vertexBuffer ()->begin ();
+		gWindow->vertexBuffer ()->end ();
+
+		paintGlow (transform, attrib, infiniteRegion, mask);
+	    }
+	}
+
+  }
+
+  return status;
+
 }
 
 #define EXPO_GRID_SIZE 100
@@ -1425,11 +1696,17 @@
 		     const CompRegion&          region,
 		     unsigned int               mask)
 {
+    GLMatrix            wTransform (transform);
+    GLWindowPaintAttrib wAttrib (attrib);
+    CompRegion          clip (region);
+
     if (eScreen->expoActive)
     {
 	float opacity = 1.0;
 	bool  hide;
 	bool  zoomAnim;
+	CompPoint vp;
+	screen->viewportForGeometry (window->geometry (), vp);
 
 	zoomAnim = eScreen->optionGetExpoAnimation () ==
 	           ExpoScreen::ExpoAnimationZoom;
@@ -1458,9 +1735,47 @@
 
 	if (opacity <= 0)
 	    mask |= PAINT_WINDOW_NO_CORE_INSTANCE_MASK;
+	else
+	    wAttrib.opacity = wAttrib.opacity * opacity;
+
+	/* Stretch maximized windows a little so that you don't
+	 * have an awkward gap */
+
+	if (window->state () & MAXIMIZE_STATE &&
+		!window->border ().top)
+	{
+	    CompOutput *o = &screen->outputDevs ()[screen->outputDeviceForGeometry(window->geometry())];
+	    float yS = 1.0 + ((o->height () / (float) window->height ()) - 1.0f) * sigmoidProgress (eScreen->expoCam);
+	    float xS = 1.0 + ((o->width () / (float) window->width ()) - 1.0f) * sigmoidProgress (eScreen->expoCam);
+	    wTransform.translate (window->x () + window->width (),
+				  window->y () + window->height (),
+				  0.0f);
+	    wTransform.scale (xS, yS, 1.0f);
+	    wTransform.translate (-(window->x () + window->width ()),
+				  -(window->y () + window->height ()),
+				  0.0f);
+
+	    if (eScreen->paintingVp != vp)
+		mask |= PAINT_WINDOW_NO_CORE_INSTANCE_MASK;
+
+	    mask |= PAINT_WINDOW_TRANSFORMED_MASK;
+	}
+	
+	if (std::find (eScreen->dndWindows.begin(), eScreen->dndWindows.end (), window) != eScreen->dndWindows.end ())
+	{
+	    if (!eScreen->paintingDndWindow)
+	    {
+		mask |= PAINT_WINDOW_NO_CORE_INSTANCE_MASK;
+	    }
+	    else
+	    {
+		mask |= PAINT_WINDOW_TRANSFORMED_MASK;
+		clip = infiniteRegion;
+	    }
+	}
     }
 
-    return gWindow->glPaint (attrib, transform, region, mask);
+    return gWindow->glPaint (wAttrib, wTransform, clip, mask);
 }
 
 bool
@@ -1489,7 +1804,7 @@
     expoActive (false),
     expoMode (false),
     dndState (DnDNone),
-    dndWindow (NULL),
+    dndWindows (0),
     origVp (s->vp ()),
     selectedVp (s->vp ()),
     lastSelectedVp (s->vp ()),
@@ -1497,14 +1812,21 @@
     clickTime (0),
     doubleClick (false),
     vpNormals (360 * 3),
-    grabIndex (0)
-{
+    grabIndex (0),
+    paintingDndWindow (false),
+    mGlowTextureProperties (&glowTextureProperties)
+{
+    CompString fname;
+    CompString pname = "expo";
+    CompSize   size;
+
+
     leftKey  = XKeysymToKeycode (s->dpy (), XStringToKeysym ("Left"));
     rightKey = XKeysymToKeycode (s->dpy (), XStringToKeysym ("Right"));
     upKey    = XKeysymToKeycode (s->dpy (), XStringToKeysym ("Up"));
     downKey  = XKeysymToKeycode (s->dpy (), XStringToKeysym ("Down"));
 
-    dragCursor = XCreateFontCursor (screen->dpy (), XC_fleur);
+    mMoveCursor = XCreateFontCursor (screen->dpy (), XC_fleur);
 
     EXPOINITBIND (ExpoKey, doExpo);
     EXPOTERMBIND (ExpoKey, termExpo);
@@ -1522,12 +1844,58 @@
     ScreenInterface::setHandler (screen, false);
     CompositeScreenInterface::setHandler (cScreen, false);
     GLScreenInterface::setHandler (gScreen, false);
+
+    outline_texture = GLTexture::imageDataToTexture (mGlowTextureProperties->textureData,
+						     CompSize (mGlowTextureProperties->textureSize,
+							       mGlowTextureProperties->textureSize),
+						     GL_RGBA, GL_UNSIGNED_BYTE);
+    fname = "texture_tile.png";
+    polkadots_texture = GLTexture::readImageToTexture (fname, pname, polkadots_texture_size);
+
+    if (polkadots_texture.empty ())
+	compLogMessage ("expo", CompLogLevelWarn, "failed to bind image to texture");
+    else
+    {
+	foreach (GLTexture *tex, polkadots_texture)
+	{
+	    tex->enable (GLTexture::Good);
+	    glTexParameteri (tex->target (), GL_TEXTURE_WRAP_S, GL_REPEAT);
+	    glTexParameteri (tex->target (), GL_TEXTURE_WRAP_T, GL_REPEAT);
+	    tex->disable ();
+	}
+    }
 }
 
 ExpoScreen::~ExpoScreen ()
 {
-    if (dragCursor != None)
-	XFreeCursor (screen->dpy (), dragCursor);
+    if (mMoveCursor)
+	XFreeCursor (screen->dpy (), mMoveCursor);
+}
+
+void
+ExpoWindow::moveNotify (int dx, int dy, bool immediate)
+{   
+    window->moveNotify (dx, dy, immediate);
+
+    if (!ExpoScreen::get (screen)->expoActive)
+	return;
+
+    updateViewportActiveStates (screen);
+}
+
+void
+ExpoWindow::resizeNotify(int dx, int dy, int dw, int dh)
+{
+    window->resizeNotify (dx, dy, dw, dh);
+
+    /* mGlowQuads contains positional info, so we need to recalc that */
+    if (mGlowQuads)
+    {
+	/* FIXME: we need to find a more multitexture friendly way
+	 * of doing this */
+	GLTexture::Matrix tMat = eScreen->outline_texture.at (0)->matrix ();
+	computeGlowQuads (&tMat);
+    }
 }
 
 ExpoWindow::ExpoWindow (CompWindow *w) :
@@ -1535,10 +1903,28 @@
     window (w),
     cWindow (CompositeWindow::get (w)),
     gWindow (GLWindow::get (w)),
-    eScreen (ExpoScreen::get (screen))
+    eScreen (ExpoScreen::get (screen)),
+    dndOpacity (0.0f),
+    mGlowQuads (NULL)
 {
     CompositeWindowInterface::setHandler (cWindow, false);
     GLWindowInterface::setHandler (gWindow, false);
+    WindowInterface::setHandler (window, true);
+
+    if (window->type () & CompWindowTypeDesktopMask)
+    {
+	foreach (GLTexture *tex, eScreen->outline_texture)
+	{
+	    GLTexture::Matrix mat = tex->matrix ();
+	    computeGlowQuads (&mat);
+	}
+    }
+}
+
+ExpoWindow::~ExpoWindow ()
+{
+    eScreen->dndWindows.remove (window);
+    computeGlowQuads (NULL);
 }
 
 bool
Index: ubuntu/plugins/expo/src/expo.h
===================================================================
--- ubuntu.orig/plugins/expo/src/expo.h	2012-09-08 17:26:40.599035911 +0800
+++ ubuntu/plugins/expo/src/expo.h	2012-09-12 22:20:43.276760475 +0800
@@ -30,6 +30,44 @@
 #include <opengl/opengl.h>
 
 #include "expo_options.h"
+#include "glow.h"
+#include "viewport-member-window.h"
+#include "client-list-generator.h"
+
+#define WIN_REAL_X(w) (w->x () - w->border ().left)
+#define WIN_REAL_Y(w) (w->y () - w->border ().top)
+#define WIN_REAL_WIDTH(w) (w->width () + 2 * w->geometry ().border () + \
+			   w->border ().left + w->border ().right)
+#define WIN_REAL_HEIGHT(w) (w->height () + 2 * w->geometry ().border () + \
+			    w->border ().top + w->border ().bottom)
+
+namespace compiz
+{
+    namespace expo
+    {
+	namespace impl
+	{
+	    namespace ce = compiz::expo;
+
+	    class CompizClientListGenerator :
+		public ce::ClientListGenerator
+	    {
+		public:
+
+		    CompizClientListGenerator (CompScreen *screen);
+
+		    void refreshClientList ();
+		    ViewportMemberWindow * nextClient ();
+
+		private:
+
+		    CompScreen                 *mScreen;
+		    const CompWindowVector     *mClientList;
+		    CompWindowVector::const_iterator mClientListIterator;
+	    };
+	}
+    }
+}
 
 class ExpoScreen :
     public ScreenInterface,
@@ -51,8 +89,10 @@
 	bool glPaintOutput (const GLScreenPaintAttrib&, const GLMatrix&,
 			    const CompRegion&, CompOutput *, unsigned int);
 	void glPaintTransformedOutput (const GLScreenPaintAttrib&,
-				       const GLMatrix&, const CompRegion&,
-				       CompOutput *, unsigned int);
+	                               const GLMatrix&, const CompRegion&,
+	                               CompOutput*, unsigned int);
+
+	const CompWindowList & getWindowPaintList ();
 
 	bool dndInit (CompAction *, CompAction::State, CompOption::Vector&);
 	bool dndFini (CompAction *, CompAction::State, CompOption::Vector&);
@@ -62,6 +102,8 @@
 	bool nextVp (CompAction *, CompAction::State, CompOption::Vector&);
 	bool prevVp (CompAction *, CompAction::State, CompOption::Vector&);
 
+	CompPoint currentViewport ();
+
 	typedef enum {
 	    DnDNone,
 	    DnDDuring,
@@ -82,7 +124,7 @@
 	bool  expoMode;
 
 	DnDState   dndState;
-	CompWindow *dndWindow;
+	CompWindowList dndWindows;
 
 	CompPoint prevCursor;
 	CompPoint newCursor;
@@ -94,6 +136,7 @@
 	CompPoint paintingVp;
 
 	std::vector<float> vpActivity;
+	std::vector<bool>  vpActive;
 	float              vpBrightness;
 	float              vpSaturation;
 
@@ -113,6 +156,17 @@
 
 	CompScreen::GrabHandle grabIndex;
 
+	GLTexture::List polkadots_texture;
+	CompSize        polkadots_texture_size;
+	CompSize        viewport_size;
+
+	GLTexture::List outline_texture;
+	CompSize        outline_texture_size;
+
+	bool paintingDndWindow;
+
+	const GlowTextureProperties *mGlowTextureProperties;
+
     private:
 	void moveFocusViewport (int, int);
 	void finishWindowMovement ();
@@ -123,24 +177,45 @@
 	void paintWall (const GLScreenPaintAttrib&, const GLMatrix&,
 			const CompRegion&, CompOutput *, unsigned int, bool);
 
+	void paintViewport (const GLScreenPaintAttrib& attrib,
+			    const GLMatrix&            transform,
+			    const CompRegion&          region,
+			    CompOutput                 *output,
+			    unsigned int               mask,
+			    CompPoint                  vpPos,
+			    GLVector                   &vpCamPos,
+			    bool                       reflection);
+
+	bool windowsOnVp (compiz::expo::ClientListGenerator &clientList,
+			  CompPoint                         &p,
+			  const CompPoint		    &unprojectedCursor,
+			  const CompSize		    &screenSize,
+			  CompScreen			    *screen);
+
 	KeyCode leftKey;
 	KeyCode rightKey;
 	KeyCode upKey;
 	KeyCode downKey;
 
-	Cursor dragCursor;
+	Cursor  mMoveCursor;
 };
 
 class ExpoWindow :
+    public compiz::expo::ViewportMemberWindow,
     public CompositeWindowInterface,
     public GLWindowInterface,
+    public WindowInterface,
     public PluginClassHandler<ExpoWindow, CompWindow>
 {
     public:
 	ExpoWindow (CompWindow *);
+	~ExpoWindow ();
 
 	bool damageRect (bool, const CompRect&);
 
+	void resizeNotify (int dx, int dy, int dw, int dh);
+	void moveNotify (int dx, int dy, bool immediate);
+
 	bool glDraw (const GLMatrix&, const GLWindowPaintAttrib&,
 		     const CompRegion&, unsigned int);
 	bool glPaint (const GLWindowPaintAttrib&, const GLMatrix&,
@@ -150,11 +225,31 @@
 			    unsigned int, unsigned int);
 	void glDrawTexture (GLTexture*, const GLMatrix&,
 	                    const GLWindowPaintAttrib&, unsigned int);
+	void
+	paintGlow (const GLMatrix            &transform,
+	           const GLWindowPaintAttrib &attrib,
+		   const CompRegion	     &paintRegion,
+		   unsigned int		     mask);
+
+	void
+	computeGlowQuads (GLTexture::Matrix *matrix);
 
 	CompWindow      *window;
 	CompositeWindow *cWindow;
 	GLWindow        *gWindow;
 	ExpoScreen      *eScreen;
+
+	float           dndOpacity;
+
+	GlowQuad *mGlowQuads;
+
+    private:
+
+	bool isDesktopOrDock () const;
+	bool dragged () const;
+	const compiz::window::Geometry & absoluteGeometry () const;
+
+	mutable compiz::window::Geometry mAbsoluteGeometry;
 };
 
 class ExpoPluginVTable :
Index: ubuntu/plugins/expo/src/glow.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ ubuntu/plugins/expo/src/glow.cpp	2012-09-12 22:20:43.280760497 +0800
@@ -0,0 +1,429 @@
+/**
+ *
+ * Compiz group plugin
+ *
+ * glow.cpp
+ *
+ * Copyright : (C) 2006-2010 by Patrick Niklaus, Roi Cohen,
+ * 				Danny Baumann, Sam Spilsbury
+ * Authors: Patrick Niklaus <patrick.niklaus@googlemail.com>
+ *          Roi Cohen       <roico.beryl@gmail.com>
+ *          Danny Baumann   <maniac@opencompositing.org>
+ * 	    Sam Spilsbury   <smspillaz@gmail.com>
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ **/
+
+#include "expo.h"
+#include "group_glow.h"
+
+const GlowTextureProperties glowTextureProperties = {
+    /* GlowTextureRectangular */
+    glowTexRect, 32, 21
+};
+
+/*
+ * GroupWindow::paintGlow
+ *
+ * Takes our glow texture, stretches the appropriate positions in the glow texture,
+ * adds those geometries (so plugins like wobby and deform this texture correctly)
+ * and then draws the glow texture with this geometry (plugins like wobbly and friends
+ * will automatically deform the texture based on our set geometry)
+ */
+
+void
+ExpoWindow::paintGlow (const GLMatrix            &transform,
+                       const GLWindowPaintAttrib &attrib,
+                       const CompRegion          &paintRegion,
+                       unsigned int               mask)
+{
+    CompRegion      reg;
+    int             i;
+    GLushort        colorData[4];
+    const GLushort *selColorData = ExpoScreen::get (screen)->optionGetSelectedColor ();
+    float           alpha = (float) selColorData[3] / 65535.0f;
+
+    /* Premultiply color */
+    colorData[0] = selColorData[0] * alpha;
+    colorData[1] = selColorData[1] * alpha;
+    colorData[2] = selColorData[2] * alpha;
+    colorData[3] = selColorData[3];
+
+    gWindow->vertexBuffer ()->begin ();
+
+    /* There are 8 glow parts of the glow texture which we wish to paint
+     * separately with different transformations
+     */
+    for (i = 0; i < NUM_GLOWQUADS; i++)
+    {
+	/* Using precalculated quads here */
+	reg = CompRegion (mGlowQuads[i].mBox);
+
+	if (reg.boundingRect ().x1 () < reg.boundingRect ().x2 () &&
+	    reg.boundingRect ().y1 () < reg.boundingRect ().y2 ())
+	{
+	    GLTexture::MatrixList matl;
+	    reg = CompRegion (reg.boundingRect ().x1 (),
+			      reg.boundingRect ().y1 (),
+			      reg.boundingRect ().width (),
+			      reg.boundingRect ().height ());
+
+	    matl.push_back (mGlowQuads[i].mMatrix);
+	    /* Add color data for all 6 vertices of the quad */
+	    for (int n = 0; n < 6; n++)
+		gWindow->vertexBuffer ()->addColors (1, colorData);
+	    gWindow->glAddGeometry (matl, reg, paintRegion);
+	}
+    }
+
+    if (gWindow->vertexBuffer ()->end ())
+    {
+	//GLScreen::get (screen)->setTexEnvMode (GL_MODULATE);
+	glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+
+	/* we use PAINT_WINDOW_TRANSFORMED_MASK here to force
+	the usage of a good texture filter */
+	foreach (GLTexture *tex, ExpoScreen::get (screen)->outline_texture)
+	{
+	    gWindow->glDrawTexture (tex, transform, attrib, mask | 
+				    PAINT_WINDOW_BLEND_MASK       |
+				    PAINT_WINDOW_TRANSLUCENT_MASK |
+				    PAINT_WINDOW_TRANSFORMED_MASK);
+	}
+
+	glBlendFunc (GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
+	GLScreen::get (screen)->setTexEnvMode (GL_REPLACE);
+    }
+}
+
+/*
+ * ExpoWindow::computeGlowQuads
+ *
+ * This function computures the matrix transformation required for each
+ * part of the glow texture which we wish to stretch to some rectangular
+ * dimentions
+ *
+ * There are eight quads different parts of the texture which we wish to
+ * paint here, the 4 sides and four corners, eg:
+ *
+ *		     ------------------
+ *		     | 1 |   4    | 6 |
+ * -------------     ------------------
+ * | 1 | 4 | 6 |     |   |        |   |
+ * -------------     |   |	  |   |
+ * | 2 | n | 7 | ->  | 2 |   n    | 7 |
+ * -------------     |   |        |   |
+ * | 3 | 5 | 8 |     |   |        |   |
+ * -------------     ------------------
+ *		     | 3 |   5    | 8 |
+ *		     ------------------
+ *
+ * In this example here, 2, 4, 5 and 7 are stretched, and the matrices for
+ * each quad rect adjusted accordingly for it's size compared to the original
+ * texture size.
+ *
+ * When we are adjusting the matrices here, the initial size of each corner has
+ * a size of of "1.0f", so according to 2x2 matrix rules,
+ * the scale factor is the inverse of the size of the glow (which explains
+ * while you will see here that matrix->xx is (1 / glowSize)
+ * where glowSize is the size the user specifies they want their glow to extend.
+ * (likewise, matrix->yy is adjusted similarly for corners and for top/bottom)
+ *
+ * matrix->x0 and matrix->y0 here are set to be the top left edge of the rect
+ * adjusted by the matrix scale factor (matrix->xx and matrix->yy)
+ *
+ */
+void
+ExpoWindow::computeGlowQuads (GLTexture::Matrix *matrix)
+{
+    CompRect	      *box;
+    int		      x1, x2, y1, y2;
+    GLTexture::Matrix *quadMatrix;
+    int               glowSize, glowOffset;
+    CompWindow	      *w = window;
+
+    /* Passing NULL to this function frees the glow quads
+     * (so the window is not painted with glow) */
+
+    if (matrix)
+    {
+	if (!mGlowQuads)
+	    mGlowQuads = new GlowQuad[NUM_GLOWQUADS];
+	if (!mGlowQuads)
+	    return;
+    }
+    else
+    {
+	if (mGlowQuads)
+	{
+	    delete[] mGlowQuads;
+	    mGlowQuads = NULL;
+	}
+	return;
+    }
+
+    glowSize = 48;
+    glowOffset = (glowSize * ExpoScreen::get (screen)->mGlowTextureProperties->glowOffset /
+		  ExpoScreen::get (screen)->mGlowTextureProperties->textureSize) + 1;
+
+    /* Top left corner */
+    box = &mGlowQuads[GLOWQUAD_TOPLEFT].mBox;
+    mGlowQuads[GLOWQUAD_TOPLEFT].mMatrix = *matrix;
+    quadMatrix = &mGlowQuads[GLOWQUAD_TOPLEFT].mMatrix;
+
+    /* Set the desired rect dimentions
+     * for the part of the glow we are painting */
+
+    x1 = WIN_REAL_X (w) - glowSize + glowOffset;
+    y1 = WIN_REAL_Y (w) - glowSize + glowOffset;
+
+    /* 2x2 Matrix here, adjust both x and y scale factors
+     * and the x and y position
+     *
+     * Scaling both parts of the texture in a positive direction
+     * here (left to right top to bottom)
+     *
+     * The base position (x0 and y0) here requires us to move backwards
+     * on the x and y dimentions by the calculated rect dimentions
+     * multiplied by the scale factors
+     */
+
+    quadMatrix->xx = 1.0f / glowSize;
+    quadMatrix->yy = 1.0f / (glowSize);
+    quadMatrix->x0 = -(x1 * quadMatrix->xx);
+    quadMatrix->y0 = -(y1 * quadMatrix->yy);
+
+    x2 = MIN (WIN_REAL_X (w) + glowOffset,
+	      WIN_REAL_X (w) + (WIN_REAL_WIDTH (w) / 2));
+    y2 = MIN (WIN_REAL_Y (w) + glowOffset,
+	      WIN_REAL_Y (w) + (WIN_REAL_HEIGHT (w) / 2));
+
+    *box = CompRect (x1, y1, x2 - x1, y2 - y1);
+
+    /* Top right corner */
+    box = &mGlowQuads[GLOWQUAD_TOPRIGHT].mBox;
+    mGlowQuads[GLOWQUAD_TOPRIGHT].mMatrix = *matrix;
+    quadMatrix = &mGlowQuads[GLOWQUAD_TOPRIGHT].mMatrix;
+
+    /* Set the desired rect dimentions
+     * for the part of the glow we are painting */
+
+    x1 = WIN_REAL_X (w) + WIN_REAL_WIDTH (w) - glowOffset;
+    y1 = WIN_REAL_Y (w) - glowSize + glowOffset;
+    x2 = WIN_REAL_X (w) + WIN_REAL_WIDTH (w) + glowSize - glowOffset;
+
+    /* 2x2 Matrix here, adjust both x and y scale factors
+     * and the x and y position
+     *
+     * Scaling the y part of the texture in a positive direction
+     * and the x part in a negative direction here
+     * (right to left top to bottom)
+     *
+     * The base position (x0 and y0) here requires us to move backwards
+     * on the y dimention and forwards on x by the calculated rect dimentions
+     * multiplied by the scale factors (since we are moving forward on x we
+     * need the inverse of that which is 1 - x1 * xx
+     */
+
+    quadMatrix->xx = -1.0f / glowSize;
+    quadMatrix->yy = 1.0f / glowSize;
+    quadMatrix->x0 = 1.0 - (x1 * quadMatrix->xx);
+    quadMatrix->y0 = -(y1 * quadMatrix->yy);
+
+    x1 = MAX (WIN_REAL_X (w) + WIN_REAL_WIDTH (w) - glowOffset,
+	      WIN_REAL_X (w) + (WIN_REAL_WIDTH (w) / 2));
+    y2 = MIN (WIN_REAL_Y (w) + glowOffset,
+	      WIN_REAL_Y (w) + (WIN_REAL_HEIGHT (w) / 2));
+
+    *box = CompRect (x1, y1, x2 - x1, y2 - y1);
+
+    /* Bottom left corner */
+    box = &mGlowQuads[GLOWQUAD_BOTTOMLEFT].mBox;
+    mGlowQuads[GLOWQUAD_BOTTOMLEFT].mMatrix = *matrix;
+    quadMatrix = &mGlowQuads[GLOWQUAD_BOTTOMLEFT].mMatrix;
+
+    x1 = WIN_REAL_X (w) - glowSize + glowOffset;
+    y1 = WIN_REAL_Y (w) + WIN_REAL_HEIGHT (w) - glowOffset;
+    x2 = WIN_REAL_X (w) + glowOffset;
+    y2 = WIN_REAL_Y (w) + WIN_REAL_HEIGHT (w) + glowSize - glowOffset;
+
+    /* 2x2 Matrix here, adjust both x and y scale factors
+     * and the x and y position
+     *
+     * Scaling the x part of the texture in a positive direction
+     * and the y part in a negative direction here
+     * (left to right bottom to top)
+     *
+     * The base position (x0 and y0) here requires us to move backwards
+     * on the x dimention and forwards on y by the calculated rect dimentions
+     * multiplied by the scale factors (since we are moving forward on x we
+     * need the inverse of that which is 1 - y1 * yy
+     */
+
+    quadMatrix->xx = 1.0f / glowSize;
+    quadMatrix->yy = -1.0f / glowSize;
+    quadMatrix->x0 = -(x1 * quadMatrix->xx);
+    quadMatrix->y0 = 1.0f - (y1 * quadMatrix->yy);
+
+    y1 = MAX (WIN_REAL_Y (w) + WIN_REAL_HEIGHT (w) - glowOffset,
+	      WIN_REAL_Y (w) + (WIN_REAL_HEIGHT (w) / 2));
+    x2 = MIN (WIN_REAL_X (w) + glowOffset,
+	      WIN_REAL_X (w) + (WIN_REAL_WIDTH (w) / 2));
+
+    *box = CompRect (x1, y1, x2 - x1, y2 - y1);
+
+    /* Bottom right corner */
+    box = &mGlowQuads[GLOWQUAD_BOTTOMRIGHT].mBox;
+    mGlowQuads[GLOWQUAD_BOTTOMRIGHT].mMatrix = *matrix;
+    quadMatrix = &mGlowQuads[GLOWQUAD_BOTTOMRIGHT].mMatrix;
+
+    x1 = WIN_REAL_X (w) + WIN_REAL_WIDTH (w) - glowOffset;
+    y1 = WIN_REAL_Y (w) + WIN_REAL_HEIGHT (w) - glowOffset;
+    x2 = WIN_REAL_X (w) + WIN_REAL_WIDTH (w) + glowSize - glowOffset;
+    y2 = WIN_REAL_Y (w) + WIN_REAL_HEIGHT (w) + glowSize - glowOffset;
+
+    /* 2x2 Matrix here, adjust both x and y scale factors
+     * and the x and y position
+     *
+     * Scaling the both parts of the texture in a negative direction
+     * (right to left bottom to top)
+     *
+     * The base position (x0 and y0) here requires us to move forwards
+     * on both dimentions by the calculated rect dimentions
+     * multiplied by the scale factors
+     */
+
+    quadMatrix->xx = -1.0f / glowSize;
+    quadMatrix->yy = -1.0f / glowSize;
+    quadMatrix->x0 = 1.0 - (x1 * quadMatrix->xx);
+    quadMatrix->y0 = 1.0 - (y1 * quadMatrix->yy);
+
+    x1 = MAX (WIN_REAL_X (w) + WIN_REAL_WIDTH (w) - glowOffset,
+	      WIN_REAL_X (w) + (WIN_REAL_WIDTH (w) / 2));
+    y1 = MAX (WIN_REAL_Y (w) + WIN_REAL_HEIGHT (w) - glowOffset,
+	      WIN_REAL_Y (w) + (WIN_REAL_HEIGHT (w) / 2));
+
+    *box = CompRect (x1, y1, x2 - x1, y2 - y1);
+
+    /* Top edge */
+    box = &mGlowQuads[GLOWQUAD_TOP].mBox;
+    mGlowQuads[GLOWQUAD_TOP].mMatrix = *matrix;
+    quadMatrix = &mGlowQuads[GLOWQUAD_TOP].mMatrix;
+
+    x1 = WIN_REAL_X (w) + glowOffset;
+    y1 = WIN_REAL_Y (w) - glowSize + glowOffset;
+    x2 = WIN_REAL_X (w) + WIN_REAL_WIDTH (w) - glowOffset;
+    y2 = WIN_REAL_Y (w) + glowOffset;
+
+    /* 2x2 Matrix here, adjust both x and y scale factors
+     * and the x and y position
+     *
+     * No need to scale the x part of the texture here, but we
+     * are scaling on the y part in a positive direciton
+     *
+     * The base position (y0) here requires us to move backwards
+     * on the x dimention and forwards on y by the calculated rect dimentions
+     * multiplied by the scale factors
+     */
+
+    quadMatrix->xx = 0.0f;
+    quadMatrix->yy = 1.0f / glowSize;
+    quadMatrix->x0 = 1.0;
+    quadMatrix->y0 = -(y1 * quadMatrix->yy);
+
+    *box = CompRect (x1, y1, x2 - x1, y2 - y1);
+
+    /* Bottom edge */
+    box = &mGlowQuads[GLOWQUAD_BOTTOM].mBox;
+    mGlowQuads[GLOWQUAD_BOTTOM].mMatrix = *matrix;
+    quadMatrix = &mGlowQuads[GLOWQUAD_BOTTOM].mMatrix;
+
+    x1 = WIN_REAL_X (w) + glowOffset;
+    y1 = WIN_REAL_Y (w) + WIN_REAL_HEIGHT (w) - glowOffset;
+    x2 = WIN_REAL_X (w) + WIN_REAL_WIDTH (w) - glowOffset;
+    y2 = WIN_REAL_Y (w) + WIN_REAL_HEIGHT (w) + glowSize - glowOffset;
+
+    /* 2x2 Matrix here, adjust both x and y scale factors
+     * and the x and y position
+     *
+     * No need to scale the x part of the texture here, but we
+     * are scaling on the y part in a negative direciton
+     *
+     * The base position (y0) here requires us to move forwards
+     * on y by the calculated rect dimentions
+     * multiplied by the scale factors
+     */
+
+    quadMatrix->xx = 0.0f;
+    quadMatrix->yy = -1.0f / glowSize;
+    quadMatrix->x0 = 1.0;
+    quadMatrix->y0 = 1.0 - (y1 * quadMatrix->yy);
+
+    *box = CompRect (x1, y1, x2 - x1, y2 - y1);
+
+    /* Left edge */
+    box = &mGlowQuads[GLOWQUAD_LEFT].mBox;
+    mGlowQuads[GLOWQUAD_LEFT].mMatrix = *matrix;
+    quadMatrix = &mGlowQuads[GLOWQUAD_LEFT].mMatrix;
+
+    x1 = WIN_REAL_X (w) - glowSize + glowOffset;
+    y1 = WIN_REAL_Y (w) + glowOffset;
+    x2 = WIN_REAL_X (w) + glowOffset;
+    y2 = WIN_REAL_Y (w) + WIN_REAL_HEIGHT (w) - glowOffset;
+
+    /* 2x2 Matrix here, adjust both x and y scale factors
+     * and the x and y position
+     *
+     * No need to scale the y part of the texture here, but we
+     * are scaling on the x part in a positive direciton
+     *
+     * The base position (x0) here requires us to move backwards
+     * on x by the calculated rect dimentions
+     * multiplied by the scale factors
+     */
+
+    quadMatrix->xx = 1.0f / glowSize;
+    quadMatrix->yy = 0.0f;
+    quadMatrix->x0 = -(x1 * quadMatrix->xx);
+    quadMatrix->y0 = 1.0;
+
+    *box = CompRect (x1, y1, x2 - x1, y2 - y1);
+
+    /* Right edge */
+    box = &mGlowQuads[GLOWQUAD_RIGHT].mBox;
+    mGlowQuads[GLOWQUAD_RIGHT].mMatrix = *matrix;
+    quadMatrix = &mGlowQuads[GLOWQUAD_RIGHT].mMatrix;
+
+    x1 = WIN_REAL_X (w) + WIN_REAL_WIDTH (w) - glowOffset;
+    y1 = WIN_REAL_Y (w) + glowOffset;
+    x2 = WIN_REAL_X (w) + WIN_REAL_WIDTH (w) + glowSize - glowOffset;
+    y2 = WIN_REAL_Y (w) + WIN_REAL_HEIGHT (w) - glowOffset;
+
+    /* 2x2 Matrix here, adjust both x and y scale factors
+     * and the x and y position
+     *
+     * No need to scale the y part of the texture here, but we
+     * are scaling on the x part in a negative direciton
+     *
+     * The base position (x0) here requires us to move forwards
+     * on x by the calculated rect dimentions
+     * multiplied by the scale factors
+     */
+
+    quadMatrix->xx = -1.0f / glowSize;
+    quadMatrix->yy = 0.0f;
+    quadMatrix->x0 = 1.0 - (x1 * quadMatrix->xx);
+    quadMatrix->y0 = 1.0;
+
+    *box = CompRect (x1, y1, x2 - x1, y2 - y1);
+}
Index: ubuntu/plugins/expo/src/glow.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ ubuntu/plugins/expo/src/glow.h	2012-09-12 22:20:43.280760497 +0800
@@ -0,0 +1,66 @@
+/**
+ *
+ * Compiz group plugin
+ *
+ * glow.h
+ *
+ * Copyright : (C) 2006-2010 by Patrick Niklaus, Roi Cohen,
+ * 				Danny Baumann, Sam Spilsbury
+ * Authors: Patrick Niklaus <patrick.niklaus@googlemail.com>
+ *          Roi Cohen       <roico.beryl@gmail.com>
+ *          Danny Baumann   <maniac@opencompositing.org>
+ * 	    Sam Spilsbury   <smspillaz@gmail.com>
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ **/
+ 
+#ifndef _EXPO_GLOW_H
+#define _EXPO_GLOW_H
+ 
+#define GLOWQUAD_TOPLEFT	 0
+#define GLOWQUAD_TOPRIGHT	 1
+#define GLOWQUAD_BOTTOMLEFT	 2
+#define GLOWQUAD_BOTTOMRIGHT     3
+#define GLOWQUAD_TOP		 4
+#define GLOWQUAD_BOTTOM		 5
+#define GLOWQUAD_LEFT		 6
+#define GLOWQUAD_RIGHT		 7
+#define NUM_GLOWQUADS		 8
+
+/* Represents a particular glow texture, so here
+ * we have hardcoded in the texture data, the offset
+ * and the size of the texture
+ */
+
+typedef struct _GlowTextureProperties {
+    char *textureData;
+    int  textureSize;
+    int  glowOffset;
+} GlowTextureProperties;
+
+/* Each glow quad contains a 2x2 scale + positional matrix
+ * (the 3rd column is not used since that is for matrix skew
+ *  operations which we do not care about)
+ * and also a CompRect which describes the size and position of
+ * the quad on the glow
+ */
+
+class GlowQuad {
+    public:
+	CompRect	  mBox;
+	GLTexture::Matrix mMatrix;
+};
+
+extern const GlowTextureProperties glowTextureProperties;
+
+#endif
Index: ubuntu/plugins/expo/src/group_glow.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ ubuntu/plugins/expo/src/group_glow.h	2012-09-12 22:20:43.280760497 +0800
@@ -0,0 +1,197 @@
+#ifndef _GROUP_GLOWTEX_H
+#define _GROUP_GLOWTEX_H
+
+/**
+ *
+ * Compiz group plugin
+ *
+ * group_glow.h
+ *
+ * Copyright : (C) 2006-2010 by Patrick Niklaus, Roi Cohen,
+ * 				Danny Baumann, Sam Spilsbury
+ * Authors: Patrick Niklaus <patrick.niklaus@googlemail.com>
+ *          Roi Cohen       <roico.beryl@gmail.com>
+ *          Danny Baumann   <maniac@opencompositing.org>
+ * 	    Sam Spilsbury   <smspillaz@gmail.com>
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ **/
+
+/*
+ * glowTex
+ */
+
+static char glowTexRect[4097] = {
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\6\377"
+  "\377\377\6\377\377\377\6\377\377\377\6\377\377\377\6\377\377\377\6\377\377"
+  "\377\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\377\377\377\6\377\377\377\6\377\377\377\6\377\377"
+  "\377\6\377\377\377\6\377\377\377\6\377\377\377\6\377\377\377\6\377\377\377"
+  "\6\377\377\377\6\377\377\377\6\377\377\377\6\377\377\377\6\377\377\377\6"
+  "\377\377\377\14\377\377\377\14\377\377\377\14\377\377\377\14\377\377\377"
+  "\14\377\377\377\14\377\377\377\14\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\377\377\377\6\377\377\377\6\377\377\377\6\377\377\377\14"
+  "\377\377\377\14\377\377\377\22\377\377\377\22\377\377\377\22\377\377\377"
+  "\27\377\377\377\27\377\377\377\27\377\377\377\27\377\377\377\27\377\377\377"
+  "\27\377\377\377\27\377\377\377\27\377\377\377\27\377\377\377\27\377\377\377"
+  "\35\377\377\377\35\377\377\377\35\377\377\377\35\377\377\377\35\377\377\377"
+  "\35\377\377\377\35\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377"
+  "\377\6\377\377\377\6\377\377\377\14\377\377\377\22\377\377\377\27\377\377"
+  "\377\27\377\377\377\35\377\377\377#\377\377\377'\377\377\377'\377\377\377"
+  "+\377\377\377+\377\377\377+\377\377\377+\377\377\377+\377\377\377+\377\377"
+  "\377+\377\377\377+\377\377\377+\377\377\3771\377\377\3771\377\377\3771\377"
+  "\377\3771\377\377\3771\377\377\3771\377\377\3771\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\377\377\377\6\377\377\377\14\377\377\377\22\377\377\377"
+  "\27\377\377\377\35\377\377\377#\377\377\377+\377\377\3771\377\377\3776\377"
+  "\377\377<\377\377\377>\377\377\377C\377\377\377I\377\377\377I\377\377\377"
+  "I\377\377\377I\377\377\377I\377\377\377I\377\377\377I\377\377\377I\377\377"
+  "\377L\377\377\377L\377\377\377L\377\377\377L\377\377\377L\377\377\377L\377"
+  "\377\377L\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\6\377\377\377\14\377"
+  "\377\377\22\377\377\377\27\377\377\377#\377\377\377+\377\377\3776\377\377"
+  "\377C\377\377\377L\377\377\377U\377\377\377]\377\377\377`\377\377\377d\377"
+  "\377\377h\377\377\377k\377\377\377k\377\377\377k\377\377\377k\377\377\377"
+  "k\377\377\377k\377\377\377k\377\377\377p\377\377\377p\377\377\377p\377\377"
+  "\377p\377\377\377p\377\377\377p\377\377\377p\0\0\0\0\0\0\0\0\0\0\0\0\377"
+  "\377\377\6\377\377\377\14\377\377\377\22\314\314\314\35\377\377\377'\377"
+  "\377\3771\377\377\377>\357\357\357P\377\377\377]\363\363\363k\365\365\365"
+  "v\365\365\365|\377\377\377\202\367\367\367\210\367\367\367\214\367\367\367"
+  "\216\367\367\367\221\367\367\367\221\367\367\367\221\367\367\367\221\367"
+  "\367\367\221\367\367\367\221\367\367\367\224\367\367\367\224\367\367\367"
+  "\224\367\367\367\224\367\367\367\224\367\367\367\224\367\367\367\224\0\0"
+  "\0\0\0\0\0\0\377\377\377\6\377\377\377\6\377\377\377\22\377\377\377\27\377"
+  "\377\377'\377\377\3776\377\377\377I\377\377\377Y\377\377\377k\376\376\376"
+  "y\377\377\377\210\377\377\377\224\377\377\377\235\377\377\377\245\377\377"
+  "\377\253\377\377\377\255\377\377\377\262\377\377\377\262\377\377\377\263"
+  "\377\377\377\263\377\377\377\263\377\377\377\263\377\377\377\263\377\377"
+  "\377\266\377\377\377\266\377\377\377\266\377\377\377\266\377\377\377\266"
+  "\377\377\377\266\377\377\377\266\0\0\0\0\0\0\0\0\377\377\377\6\377\377\377"
+  "\14\377\377\377\27\377\377\377#\377\377\3771\377\377\377I\377\377\377]\377"
+  "\377\377r\377\377\377\205\377\377\377\231\377\377\377\247\377\377\377\263"
+  "\377\377\377\275\377\377\377\304\377\377\377\310\377\377\377\313\377\377"
+  "\377\316\377\377\377\320\377\377\377\320\377\377\377\320\377\377\377\320"
+  "\377\377\377\320\377\377\377\320\377\377\377\322\377\377\377\322\377\377"
+  "\377\322\377\377\377\322\377\377\377\322\377\377\377\322\377\377\377\322"
+  "\0\0\0\0\377\377\377\6\377\377\377\6\377\377\377\22\377\377\377\35\377\377"
+  "\377+\377\377\377>\377\377\377Y\377\377\377r\377\377\377\210\376\376\376"
+  "\237\377\377\377\262\377\377\377\302\377\377\377\313\377\377\377\324\377"
+  "\377\377\332\376\376\376\336\377\377\377\341\377\377\377\342\377\377\377"
+  "\344\377\377\377\344\377\377\377\344\377\377\377\344\377\377\377\344\377"
+  "\377\377\344\377\377\377\345\377\377\377\345\377\377\377\345\377\377\377"
+  "\345\377\377\377\345\377\377\377\345\377\377\377\345\0\0\0\0\377\377\377"
+  "\6\377\377\377\14\377\377\377\27\377\377\377#\377\377\3776\377\377\377P\377"
+  "\377\377k\377\377\377\205\376\376\376\237\372\372\372\266\377\377\377\307"
+  "\373\373\373\325\373\373\373\337\374\374\374\345\374\374\374\352\374\374"
+  "\374\355\374\374\374\357\374\374\374\360\374\374\374\361\374\374\374\361"
+  "\374\374\374\362\374\374\374\362\374\374\374\362\374\374\374\362\374\374"
+  "\374\362\374\374\374\362\374\374\374\362\374\374\374\362\374\374\374\362"
+  "\374\374\374\362\374\374\374\362\0\0\0\0\377\377\377\6\377\377\377\14\377"
+  "\377\377\35\377\377\377+\377\377\377C\377\377\377]\377\377\377|\377\377\377"
+  "\231\377\377\377\263\377\377\377\307\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377"
+  "\377\377\6\377\377\377\22\324\324\324#\377\377\3771\377\377\377L\363\363"
+  "\363k\377\377\377\210\377\377\377\247\377\377\377\302\377\377\377\325\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\377\377\377\6\377\377\377\14\377\377\377\22\377\377"
+  "\377#\377\377\377<\377\377\377U\377\377\377v\377\377\377\226\377\377\377"
+  "\263\377\377\377\315\377\377\377\337\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377"
+  "\6\377\377\377\14\377\377\377\27\377\377\377'\377\377\377>\377\377\377]\377"
+  "\377\377|\370\370\370\237\377\377\377\275\373\373\373\325\377\377\377\345"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\6\377\377\377\14\377\377\377\27\377"
+  "\377\377+\377\377\377C\377\377\377`\377\377\377\202\377\377\377\247\377\377"
+  "\377\304\377\377\377\332\377\377\377\352\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377"
+  "\377\6\377\377\377\14\377\377\377\27\377\377\377+\377\377\377C\377\377\377"
+  "d\377\377\377\210\377\377\377\253\377\377\377\310\376\376\376\336\374\374"
+  "\374\355\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\6\377\377\377\14\377\377\377"
+  "\35\377\377\377+\377\377\377I\377\377\377h\377\377\377\214\377\377\377\260"
+  "\377\377\377\313\374\374\374\342\374\374\374\357\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\377\377\377\6\377\377\377\14\377\377\377\35\342\342\3421\377\377\377I\377"
+  "\377\377k\377\377\377\216\377\377\377\262\377\377\377\316\374\374\374\344"
+  "\377\377\377\360\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\6\377\377\377\14\377"
+  "\377\377\35\377\377\3771\377\377\377L\377\377\377k\377\377\377\221\377\377"
+  "\377\263\377\377\377\320\377\377\377\344\377\377\377\361\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\377\377\377\6\377\377\377\14\377\377\377\35\377\377\3771\377\377"
+  "\377L\377\377\377k\377\377\377\221\377\377\377\263\377\377\377\320\377\377"
+  "\377\344\374\374\374\362\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\6\377\377\377"
+  "\14\377\377\377\35\377\377\3771\377\377\377L\364\364\364p\377\377\377\221"
+  "\372\372\372\266\377\377\377\320\374\374\374\345\377\377\377\362\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\377\377\377\6\377\377\377\14\377\377\377\35\377\377\377"
+  "1\377\377\377L\377\377\377p\377\377\377\221\377\377\377\266\373\373\373\322"
+  "\377\377\377\345\377\377\377\362\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\6\377"
+  "\377\377\14\377\377\377\35\377\377\3771\377\377\377L\377\377\377p\377\377"
+  "\377\221\377\377\377\266\373\373\373\322\377\377\377\345\377\377\377\362"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\6\377\377\377\14\377\377\377\35\377"
+  "\377\3771\377\377\377L\377\377\377p\377\377\377\221\377\377\377\266\373\373"
+  "\373\322\377\377\377\345\377\377\377\362\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377"
+  "\377\6\377\377\377\14\377\377\377\35\377\377\3771\377\377\377L\377\377\377"
+  "p\367\367\367\224\377\377\377\266\377\377\377\322\377\377\377\345\374\374"
+  "\374\362\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\6\377\377\377\14\377\377\377"
+  "\35\377\377\3771\377\377\377L\377\377\377p\367\367\367\224\377\377\377\266"
+  "\377\377\377\322\377\377\377\345\374\374\374\362\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\377\377\377\6\377\377\377\14\377\377\377\35\377\377\3771\377\377\377L\377"
+  "\377\377p\367\367\367\224\377\377\377\266\377\377\377\322\377\377\377\345"
+  "\374\374\374\362\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\6\377\377\377\14\377"
+  "\377\377\35\377\377\3771\377\377\377L\377\377\377p\367\367\367\224\377\377"
+  "\377\266\377\377\377\322\377\377\377\345\374\374\374\362\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\377\377\377\6\377\377\377\14\377\377\377\35\377\377\3771\377\377"
+  "\377L\377\377\377p\367\367\367\224\377\377\377\266\377\377\377\322\377\377"
+  "\377\345\374\374\374\362\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\6\377\377\377"
+  "\14\377\377\377\35\377\377\3771\377\377\377L\377\377\377p\367\367\367\224"
+  "\377\377\377\266\377\377\377\322\377\377\377\345\374\374\374\362\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\377\377\377\6\377\377\377\14\377\377\377\35\377\377\377"
+  "1\377\377\377L\377\377\377p\367\367\367\224\377\377\377\266\377\377\377\322"
+  "\377\377\377\345\374\374\374\362\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
+};
+
+#endif
Index: ubuntu/plugins/expo/src/wall_offset/CMakeLists.txt
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ ubuntu/plugins/expo/src/wall_offset/CMakeLists.txt	2012-09-12 22:20:43.280760497 +0800
@@ -0,0 +1,33 @@
+include_directories (
+  ${CMAKE_CURRENT_SOURCE_DIR}/include
+  ${CMAKE_CURRENT_SOURCE_DIR}/src
+  ${Boost_INCLUDE_DIRS}
+  ${GLIBMM_INCLUDE_DIRS}
+)
+
+link_directories (${GLIBMM_LIBRARY_DIRS} ${COMPIZ_LIBRARY_DIRS})
+
+set (
+  PRIVATE_HEADERS
+  ${CMAKE_CURRENT_SOURCE_DIR}/include/wall-offset.h
+)
+
+set (
+  SRCS
+  ${CMAKE_CURRENT_SOURCE_DIR}/src/wall-offset.cpp
+)
+
+add_library (
+  compiz_expo_wall_offset STATIC
+  ${SRCS}
+  ${PRIVATE_HEADERS}
+)
+
+if (COMPIZ_BUILD_TESTING)
+  add_subdirectory ( ${CMAKE_CURRENT_SOURCE_DIR}/tests )
+endif (COMPIZ_BUILD_TESTING)
+
+target_link_libraries (
+  compiz_expo_wall_offset
+  compiz_core
+)
Index: ubuntu/plugins/expo/src/wall_offset/include/wall-offset.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ ubuntu/plugins/expo/src/wall_offset/include/wall-offset.h	2012-09-12 22:20:43.280760497 +0800
@@ -0,0 +1,43 @@
+/**
+ * Copyright © 2012 Canonical Ltd.
+ *
+ * Authors:
+ * Sam Spilsbury <sam.spilsbury@canonical.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ **/
+
+#ifndef _COMPIZ_EXPO_WALL_OFFSET_H
+#define _COMPIZ_EXPO_WALL_OFFSET_H
+
+#include <core/point.h>
+#include <core/size.h>
+#include <core/rect.h>
+
+namespace compiz
+{
+    namespace expo
+    {
+	void
+	calculateWallOffset (const CompRect  &output,
+			     const CompPoint &offsetInScreenCoords,
+			     const CompPoint &vpSize,
+			     const CompSize  &screenSize,
+			     float           &offsetInWorldX,
+			     float           &offsetInWorldY,
+			     float	     &worldScaleFactorX,
+			     float	     &worldScaleFactorY,
+			     float           animationProgress);
+    }
+}
+
+#endif
Index: ubuntu/plugins/expo/src/wall_offset/src/wall-offset.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ ubuntu/plugins/expo/src/wall_offset/src/wall-offset.cpp	2012-09-12 22:20:43.280760497 +0800
@@ -0,0 +1,55 @@
+/**
+ * Copyright © 2012 Canonical Ltd.
+ *
+ * Authors:
+ * Sam Spilsbury <sam.spilsbury@canonical.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ **/
+#include "wall-offset.h"
+
+namespace compiz
+{
+    namespace expo
+    {
+	void
+	calculateWallOffset (const CompRect  &output,
+			     const CompPoint &offsetInScreenCoords,
+			     const CompPoint &vpSize,
+			     const CompSize  &screenSize,
+			     float           &offsetInWorldX,
+			     float           &offsetInWorldY,
+			     float	     &worldScaleFactorX,
+			     float	     &worldScaleFactorY,
+			     float           animationProgress)
+	{
+	    const float sx = screenSize.width () / static_cast <float> (output.width ());
+	    const float sy = screenSize.height () / static_cast <float> (output.height ());
+	    offsetInWorldX = 0.0;
+	    offsetInWorldY = 0.0;
+	    worldScaleFactorX = 1.0f;
+	    worldScaleFactorY = 1.0f;
+
+	    if (output.left () == 0)
+	    {
+		offsetInWorldX = ((vpSize.x () * sx) / ((float) output.width ()) * (offsetInScreenCoords.x ()) * animationProgress);
+		worldScaleFactorX = 1.0f - ((float) (offsetInScreenCoords.x ()) / (float) (output.width ())) * animationProgress;
+	    }
+
+	    if (output.top () == 0)
+	    {
+		offsetInWorldY = ((vpSize.y () * sy) / ((float) output.height ()) * (offsetInScreenCoords.y ()) * animationProgress);
+		worldScaleFactorY = 1.0f - ((float) (offsetInScreenCoords.y ()) / (float) output.height ()) * animationProgress;
+	    }
+	}
+    }
+}
Index: ubuntu/plugins/expo/src/wall_offset/tests/CMakeLists.txt
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ ubuntu/plugins/expo/src/wall_offset/tests/CMakeLists.txt	2012-09-12 22:20:43.280760497 +0800
@@ -0,0 +1,19 @@
+if (NOT GTEST_FOUND)
+  message ("Google Test not found - cannot build tests!")
+  set (COMPIZ_BUILD_TESTING OFF)
+endif (NOT GTEST_FOUND)
+
+include_directories (${GTEST_INCLUDE_DIRS})
+
+link_directories (${COMPIZ_LIBRARY_DIRS})
+
+add_executable (compiz_test_expo_wall_offset
+		${CMAKE_CURRENT_SOURCE_DIR}/test-expo-wall-offset.cpp)
+
+target_link_libraries (compiz_test_expo_wall_offset
+		       compiz_expo_wall_offset
+		       ${GTEST_BOTH_LIBRARIES}
+		       ${CMAKE_THREAD_LIBS_INIT} # Link in pthread.
+                       )
+
+compiz_discover_tests (compiz_test_expo_wall_offset COVERAGE compiz_expo_wall_offset)
Index: ubuntu/plugins/expo/src/wall_offset/tests/test-expo-wall-offset.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ ubuntu/plugins/expo/src/wall_offset/tests/test-expo-wall-offset.cpp	2012-09-12 22:20:43.280760497 +0800
@@ -0,0 +1,263 @@
+/*
+ * Copyright © 2012 Canonical Ltd.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of
+ * Canonical Ltd. not be used in advertising or publicity pertaining to
+ * distribution of the software without specific, written prior permission.
+ * Canonical Ltd. makes no representations about the suitability of this
+ * software for any purpose. It is provided "as is" without express or
+ * implied warranty.
+ *
+ * CANONICAL, LTD. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN
+ * NO EVENT SHALL CANONICAL, LTD. BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
+ * OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
+ * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
+ * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Authored by: Sam Spilsbury <sam.spilsbury@canonical.com>
+ */
+#include <tr1/tuple>
+#include <gtest/gtest.h>
+#include "wall-offset.h"
+
+using ::testing::WithParamInterface;
+using ::testing::ValuesIn;
+using ::testing::Combine;
+using ::testing::Range;
+
+class ExpoWallOffsetTest :
+    public ::testing::Test
+{
+    protected:
+
+	float offsetInWorldX;
+	float offsetInWorldY;
+	float worldScaleFactorX;
+	float worldScaleFactorY;
+};
+
+namespace
+{
+    const unsigned int nAnimationsBegin = 0;
+    const unsigned int nAnimationSteps = 20;
+
+    struct OffsetAnimationParameters
+    {
+	float offsetInWorldX;
+	float offsetInWorldY;
+	float worldScaleFactorX;
+	float worldScaleFactorY;
+    };
+
+    struct OffsetParameters
+    {
+	float offsetX;
+	float offsetY;
+	int   vpSizeWidth;
+	int   vpSizeHeight;
+	int   screenWidth;
+	int   screenHeight;
+	int   outputWidth;
+	int   outputHeight;
+	OffsetAnimationParameters animationParameters[20];
+    };
+
+    const OffsetParameters testingOffsetParameters[] =
+    {
+	{
+	    0,
+	    0,
+	    1,
+	    1,
+	    100,
+	    100,
+	    100,
+	    100,
+	    {
+		{ 0, 0, 1.0, 1.0 },
+		{ 0, 0, 1.0, 1.0 },
+		{ 0, 0, 1.0, 1.0 },
+		{ 0, 0, 1.0, 1.0 },
+		{ 0, 0, 1.0, 1.0 },
+		{ 0, 0, 1.0, 1.0 },
+		{ 0, 0, 1.0, 1.0 },
+		{ 0, 0, 1.0, 1.0 },
+		{ 0, 0, 1.0, 1.0 },
+		{ 0, 0, 1.0, 1.0 },
+		{ 0, 0, 1.0, 1.0 },
+		{ 0, 0, 1.0, 1.0 },
+		{ 0, 0, 1.0, 1.0 },
+		{ 0, 0, 1.0, 1.0 },
+		{ 0, 0, 1.0, 1.0 },
+		{ 0, 0, 1.0, 1.0 },
+		{ 0, 0, 1.0, 1.0 },
+		{ 0, 0, 1.0, 1.0 },
+		{ 0, 0, 1.0, 1.0 },
+		{ 0, 0, 1.0, 1.0 }
+	    }
+	},
+	/* Monitor 1280x800, Screen: 1280x800, Viewport Layout: 2x2, Offset: 32, 24 */
+	{
+	    32,
+	    24,
+	    2,
+	    2,
+	    1280,
+	    800,
+	    1280,
+	    800,
+	    {
+		{ 0, 0, 1, 1 },
+		{ 0.0025000001769512892, 0.0011718750465661287, 0.99874997138977051, 0.99906247854232788 },
+		{ 0.0050000003539025784, 0.0023437500931322575, 0.99750000238418579, 0.99812501668930054 },
+		{ 0.0075000002980232239, 0.0035156251396983862, 0.9962499737739563, 0.99718749523162842 },
+		{ 0.010000000707805157, 0.0046875001862645149, 0.99500000476837158, 0.9962499737739563 },
+		{ 0.012500000186264515, 0.005859375, 0.99374997615814209, 0.99531251192092896 },
+		{ 0.015000000596046448, 0.0070312502793967724, 0.99250000715255737, 0.99437499046325684 },
+		{ 0.017500000074505806, 0.0082031246274709702, 0.99124997854232788, 0.99343752861022949 },
+		{ 0.020000001415610313, 0.0093750003725290298, 0.99000000953674316, 0.99250000715255737 },
+		{ 0.022499999031424522, 0.01054687425494194, 0.98874998092651367, 0.99156248569488525 },
+		{ 0.02500000037252903, 0.01171875, 0.98750001192092896, 0.99062502384185791 },
+		{ 0.027500001713633537, 0.01289062574505806, 0.98624998331069946, 0.98968750238418579 },
+		{ 0.030000001192092896, 0.014062500558793545, 0.98500001430511475, 0.98874998092651367 },
+		{ 0.032499998807907104, 0.015234374441206455, 0.98374998569488525, 0.98781251907348633 },
+		{ 0.035000000149011612, 0.01640624925494194, 0.98250001668930054, 0.98687499761581421 },
+		{ 0.037500001490116119, 0.017578125, 0.98124998807907104, 0.98593747615814209 },
+		{ 0.040000002831220627, 0.01875000074505806, 0.98000001907348633, 0.98500001430511475 },
+		{ 0.042500000447034836, 0.019921876490116119, 0.97874999046325684, 0.98406249284744263 },
+		{ 0.044999998062849045, 0.021093748509883881, 0.97750002145767212, 0.98312497138977051 },
+		{ 0.047499999403953552, 0.02226562425494194, 0.97624999284744263, 0.98218750953674316 }
+	    }
+	},
+	/* Monitor 1280x1024, Screen: 2560x1024, Viewport Layout: 2x2, Offset: 32, 24 */
+	{
+	    32,
+	    24,
+	    2,
+	    2,
+	    2560,
+	    1024,
+	    1280,
+	    1024,
+	    {
+		{ 0, 0, 1, 1 },
+		{ 0.0050000003539025784, 0.001500000013038516, 0.99874997138977051, 0.99906247854232788 },
+		{ 0.010000000707805157, 0.0030000000260770321, 0.99750000238418579, 0.99812501668930054 },
+		{ 0.015000000596046448, 0.0045000002719461918, 0.9962499737739563, 0.99718749523162842 },
+		{ 0.020000001415610313, 0.0060000000521540642, 0.99500000476837158, 0.9962499737739563 },
+		{ 0.02500000037252903, 0.0074999998323619366, 0.99374997615814209, 0.99531251192092896 },
+		{ 0.030000001192092896, 0.0090000005438923836, 0.99250000715255737, 0.99437499046325684 },
+		{ 0.035000000149011612, 0.010499999858438969, 0.99124997854232788, 0.99343752861022949 },
+		{ 0.040000002831220627, 0.012000000104308128, 0.99000000953674316, 0.99250000715255737 },
+		{ 0.044999998062849045, 0.013499999418854713, 0.98874998092651367, 0.99156248569488525 },
+		{ 0.05000000074505806, 0.014999999664723873, 0.98750001192092896, 0.99062502384185791 },
+		{ 0.055000003427267075, 0.016499999910593033, 0.98624998331069946, 0.98968750238418579 },
+		{ 0.060000002384185791, 0.018000001087784767, 0.98500001430511475, 0.98874998092651367 },
+		{ 0.064999997615814209, 0.019499998539686203, 0.98374998569488525, 0.98781251907348633 },
+		{ 0.070000000298023224, 0.020999999716877937, 0.98250001668930054, 0.98687499761581421 },
+		{ 0.075000002980232239, 0.022499999031424522, 0.98124998807907104, 0.98593747615814209 },
+		{ 0.080000005662441254, 0.024000000208616257, 0.98000001907348633, 0.98500001430511475 },
+		{ 0.085000000894069672, 0.025499999523162842, 0.97874999046325684, 0.98406249284744263 },
+		{ 0.08999999612569809, 0.026999998837709427, 0.97750002145767212, 0.98312497138977051 },
+		{ 0.094999998807907104, 0.028499998152256012, 0.97624999284744263, 0.98218750953674316 }
+	    }
+	},
+    };
+
+    typedef std::tr1::tuple <OffsetParameters, unsigned int> AnimParam;
+}
+
+class ExpoWallOffsetTestAnimations :
+    public ExpoWallOffsetTest,
+    public ::testing::WithParamInterface <AnimParam>
+{
+    public:
+
+	void
+	RecordProperty (const char *name, float value)
+	{
+	    ::testing::Message message;
+	    message << value;
+	    Test::RecordProperty (name, message.GetString ().c_str ());
+	}
+};
+
+TEST_P (ExpoWallOffsetTestAnimations, TestAnimationValues)
+{
+    const OffsetParameters &offset (std::tr1::get <0> (GetParam ()));
+    const unsigned int     &index (std::tr1::get <1> (GetParam ()));
+
+    RecordProperty ("outputWidth", offset.outputWidth);
+    RecordProperty ("outputHeight", offset.outputHeight);
+    RecordProperty ("screenWidth", offset.screenWidth);
+    RecordProperty ("screenHeight", offset.screenHeight);
+    RecordProperty ("offsetX", offset.offsetX);
+    RecordProperty ("offsetY", offset.offsetY);
+
+    RecordProperty ("expected.offsetInWorldX", offset.animationParameters[index].offsetInWorldX);
+    RecordProperty ("expected.offsetInWorldY", offset.animationParameters[index].offsetInWorldY);
+    RecordProperty ("expected.worldScaleFactorX", offset.animationParameters[index].worldScaleFactorX);
+    RecordProperty ("expected.worldScaleFactorY", offset.animationParameters[index].worldScaleFactorY);
+
+    compiz::expo::calculateWallOffset (CompRect (0,
+						 0,
+						 offset.outputWidth,
+						 offset.outputWidth),
+				       CompPoint (offset.offsetX,
+						  offset.offsetY),
+				       CompPoint (offset.vpSizeWidth,
+						  offset.vpSizeHeight),
+				       CompSize (offset.screenWidth,
+						 offset.screenHeight),
+				       offsetInWorldX,
+				       offsetInWorldY,
+				       worldScaleFactorX,
+				       worldScaleFactorY,
+				       index / static_cast <float> (nAnimationSteps));
+
+    RecordProperty ("offsetInWorldX", offsetInWorldX);
+    RecordProperty ("offsetInWorldY", offsetInWorldY);
+    RecordProperty ("worldScaleFactorX", worldScaleFactorX);
+    RecordProperty ("worldScaleFactorY", worldScaleFactorY);
+
+    EXPECT_EQ (offsetInWorldX, offset.animationParameters[index].offsetInWorldX);
+    EXPECT_EQ (offsetInWorldY, offset.animationParameters[index].offsetInWorldY);
+    EXPECT_EQ (worldScaleFactorX, offset.animationParameters[index].worldScaleFactorX);
+    EXPECT_EQ (worldScaleFactorY, offset.animationParameters[index].worldScaleFactorY);
+}
+
+TEST_F (ExpoWallOffsetTest, TestNoOffsetIfOutputIsNotOrigin)
+{
+    compiz::expo::calculateWallOffset (CompRect (1,
+						 1,
+						 100,
+						 100),
+				       CompPoint (100,
+						  100),
+				       CompPoint (1,
+						  1),
+				       CompSize (100,
+						 100),
+				       offsetInWorldX,
+				       offsetInWorldY,
+				       worldScaleFactorX,
+				       worldScaleFactorY,
+				       1.0);
+
+    EXPECT_EQ (offsetInWorldX, 0.0f);
+    EXPECT_EQ (offsetInWorldY, 0.0f);
+    EXPECT_EQ (worldScaleFactorX, 1.0f);
+    EXPECT_EQ (worldScaleFactorY, 1.0f);
+}
+
+INSTANTIATE_TEST_CASE_P (ExpoAnimationOffsetTest,
+			 ExpoWallOffsetTestAnimations,
+			 Combine (ValuesIn (testingOffsetParameters),
+				  Range (nAnimationsBegin,
+					 nAnimationSteps)));
Index: ubuntu/plugins/expo/CMakeLists.txt
===================================================================
--- ubuntu.orig/plugins/expo/CMakeLists.txt	2012-09-08 17:26:40.599035911 +0800
+++ ubuntu/plugins/expo/CMakeLists.txt	2012-09-12 22:20:43.300760590 +0800
@@ -1,7 +1,16 @@
 find_package (Compiz REQUIRED)
 include (CompizPlugin)
 
+set (COMPIZ_EXPO_PLUGIN_SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR}/src)
+
 add_subdirectory (src/click_threshold)
 include_directories (src/click_threshold/include)
+add_subdirectory (src/wall_offset)
+include_directories (src/wall_offset/include)
+add_subdirectory (src/windows_on_viewport)
+include_directories (src/windows_on_viewport/include)
 
-compiz_plugin (expo PLUGINDEPS composite opengl LIBRARIES compiz_expo_click_threshold)
+compiz_plugin (expo PLUGINDEPS composite opengl LIBRARIES
+	       compiz_expo_click_threshold
+	       compiz_expo_wall_offset
+	       compiz_expo_windows_on_viewport)
Index: ubuntu/plugins/expo/src/windows_on_viewport/CMakeLists.txt
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ ubuntu/plugins/expo/src/windows_on_viewport/CMakeLists.txt	2012-09-12 22:20:43.300760590 +0800
@@ -0,0 +1,36 @@
+include_directories (
+  ${CMAKE_CURRENT_SOURCE_DIR}/include
+  ${CMAKE_CURRENT_SOURCE_DIR}/src
+  ${COMPIZ_INCLUDE_DIRS}
+  ${COMPIZ_EXPO_PLUGIN_SOURCE_DIR}
+  ${Boost_INCLUDE_DIRS}
+  ${GLIBMM_INCLUDE_DIRS}
+)
+
+link_directories (${GLIBMM_LIBRARY_DIRS} ${COMPIZ_LIBRARY_DIRS})
+
+set (
+  PRIVATE_HEADERS
+  ${CMAKE_CURRENT_SOURCE_DIR}/include/windows-on-viewport.h
+)
+
+set (
+  SRCS
+  ${CMAKE_CURRENT_SOURCE_DIR}/src/windows-on-viewport.cpp
+)
+
+add_library (
+  compiz_expo_windows_on_viewport STATIC
+  ${SRCS}
+  ${PRIVATE_HEADERS}
+)
+
+if (COMPIZ_BUILD_TESTING)
+  add_subdirectory ( ${CMAKE_CURRENT_SOURCE_DIR}/tests )
+endif (COMPIZ_BUILD_TESTING)
+
+target_link_libraries (
+  compiz_expo_windows_on_viewport
+  compiz_window_geometry
+  compiz_core
+)
Index: ubuntu/plugins/expo/src/windows_on_viewport/include/windows-on-viewport.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ ubuntu/plugins/expo/src/windows_on_viewport/include/windows-on-viewport.h	2012-09-12 22:31:06.807852402 +0800
@@ -0,0 +1,43 @@
+/**
+ * Copyright © 2012 Canonical Ltd.
+ *
+ * Authors:
+ * Sam Spilsbury <sam.spilsbury@canonical.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ **/
+#ifndef _COMPIZ_EXPO_WINDOWS_ON_VIEWPORT_H
+#define _COMPIZ_EXPO_WINDOWS_ON_VIEWPORT_H
+
+#include <core/point.h>
+#include <core/size.h>
+#include <core/rect.h>
+#include "client-list-generator.h"
+
+namespace compiz
+{
+    namespace expo
+    {
+	unsigned int countViewports (const CompSize &vpSize);
+
+	void fillInNewViewportActiveData (unsigned int vpCount,
+					  std::vector <bool> &vpActive);
+
+	void activeViewportsForMembers (compiz::expo::ClientListGenerator &clientList,
+					const CompPoint                   &cursor,
+					const CompSize			  &vpSize,
+					const CompSize                    &screenSize,
+					std::vector <bool>                &viewportActiveStates);
+    }
+}
+
+#endif
Index: ubuntu/plugins/expo/src/windows_on_viewport/src/windows-on-viewport.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ ubuntu/plugins/expo/src/windows_on_viewport/src/windows-on-viewport.cpp	2012-09-12 22:20:43.300760590 +0800
@@ -0,0 +1,80 @@
+/**
+ * Copyright © 2012 Canonical Ltd.
+ *
+ * Authors:
+ * Sam Spilsbury <sam.spilsbury@canonical.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ **/
+#include <cstdio>
+#include <algorithm>
+#include "windows-on-viewport.h"
+#include "viewport-member-window.h"
+
+namespace compiz
+{
+    namespace expo
+    {
+	unsigned int countViewports (const CompSize &vpSize)
+	{
+	    return vpSize.width () * vpSize.height ();
+	}
+
+	void fillInNewViewportActiveData (unsigned int vpCount,
+					  std::vector <bool> &vpActive)
+	{
+	    if (vpActive.size () < vpCount)
+	    {
+		unsigned int last = vpActive.size () - 1;
+		vpActive.resize (vpCount);
+		for (unsigned int i = last; i < vpActive.size (); i++)
+		    vpActive[i] = false;
+	    }
+	}
+
+	void activeViewportsForMembers (compiz::expo::ClientListGenerator &clientList,
+					const CompPoint                   &cursor,
+					const CompSize			  &vpSize,
+					const CompSize			  &screenSize,
+					std::vector <bool>		  &viewportActiveStates)
+	{
+	    compiz::expo::ViewportMemberWindow *vpMemberWindow = clientList.nextClient ();
+
+	    fillInNewViewportActiveData (countViewports (vpSize), viewportActiveStates);
+	    std::fill_n (viewportActiveStates.begin (), viewportActiveStates.size (), false);
+
+	    while (vpMemberWindow)
+	    {
+		if (!vpMemberWindow->isDesktopOrDock ())
+		{
+		    CompPoint viewport;
+
+		    /* If this is a dragged window, use the cursor position */
+		    if (vpMemberWindow->dragged ())
+			viewport.set (cursor.x () / screenSize.width (),
+				      cursor.y () / screenSize.height ());
+		    else
+		    {
+			const compiz::window::Geometry &geom = vpMemberWindow->absoluteGeometry ();
+			viewport.set (geom.centerX () / screenSize.width (),
+				      geom.centerY () / screenSize.height ());
+		    }
+
+		    unsigned int vpIndex = vpSize.width () * viewport.y () + viewport.x ();
+		    viewportActiveStates[vpIndex] = true;
+		}
+
+		vpMemberWindow = clientList.nextClient ();
+	    }
+	}
+    }
+}
Index: ubuntu/plugins/expo/src/windows_on_viewport/tests/CMakeLists.txt
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ ubuntu/plugins/expo/src/windows_on_viewport/tests/CMakeLists.txt	2012-09-12 22:20:43.300760590 +0800
@@ -0,0 +1,22 @@
+if (NOT GTEST_FOUND)
+  message ("Google Test not found - cannot build tests!")
+  set (COMPIZ_BUILD_TESTING OFF)
+endif (NOT GTEST_FOUND)
+
+include_directories (${GTEST_INCLUDE_DIRS})
+include_directories (${CMAKE_EXPO_PLUGIN_SOURCE_DIR})
+
+link_directories (${COMPIZ_LIBRARY_DIRS})
+
+add_executable (compiz_test_expo_windows_on_viewport
+		${CMAKE_CURRENT_SOURCE_DIR}/test-windows-on-viewport.cpp)
+
+target_link_libraries (compiz_test_expo_windows_on_viewport
+		       compiz_expo_windows_on_viewport
+		       ${GTEST_BOTH_LIBRARIES}
+		       ${CMAKE_THREAD_LIBS_INIT} # Link in pthread.
+                       ${GMOCK_LIBRARY}
+                       ${GMOCK_MAIN_LIBRARY}
+                       )
+
+compiz_discover_tests (compiz_test_expo_windows_on_viewport COVERAGE compiz_expo_windows_on_viewport)
Index: ubuntu/plugins/expo/src/windows_on_viewport/tests/test-windows-on-viewport.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ ubuntu/plugins/expo/src/windows_on_viewport/tests/test-windows-on-viewport.cpp	2012-09-12 22:20:43.304760606 +0800
@@ -0,0 +1,149 @@
+/*
+ * Copyright © 2012 Canonical Ltd.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of
+ * Canonical Ltd. not be used in advertising or publicity pertaining to
+ * distribution of the software without specific, written prior permission.
+ * Canonical Ltd. makes no representations about the suitability of this
+ * software for any purpose. It is provided "as is" without express or
+ * implied warranty.
+ *
+ * CANONICAL, LTD. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN
+ * NO EVENT SHALL CANONICAL, LTD. BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
+ * OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
+ * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
+ * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Authored by: Sam Spilsbury <sam.spilsbury@canonical.com>
+ */
+#include <gtest/gtest.h>
+#include <gmock/gmock.h>
+#include "windows-on-viewport.h"
+#include "client-list-generator.h"
+#include "viewport-member-window.h"
+
+using ::testing::InSequence;
+using ::testing::Return;
+using ::testing::ReturnNull;
+using ::testing::ReturnRef;
+
+namespace
+{
+    namespace ce = compiz::expo;
+
+    class MockViewportMemberWindow :
+	public ce::ViewportMemberWindow
+    {
+	public:
+
+	    MOCK_CONST_METHOD0 (absoluteGeometry, const compiz::window::Geometry & ());
+	    MOCK_CONST_METHOD0 (isDesktopOrDock, bool ());
+	    MOCK_CONST_METHOD0 (dragged, bool ());
+    };
+
+    class MockClientListGenerator :
+	public ce::ClientListGenerator
+    {
+	public:
+
+	    MOCK_METHOD0 (nextClient, ce::ViewportMemberWindow * ());
+    };
+}
+
+class ExpoWindowsOnViewportTest :
+    public ::testing::Test
+{
+    protected:
+
+	MockClientListGenerator mockClientListGenerator;
+	std::vector <bool>      activeStates;
+};
+
+namespace
+{
+    const CompSize vpSize (2, 2);
+    const CompSize screenSize (1000, 1000);
+}
+
+TEST_F (ExpoWindowsOnViewportTest, TestNoDocksMakeViewportsActive)
+{
+    MockViewportMemberWindow mockViewportMembers[1];
+    InSequence s;
+
+    EXPECT_CALL (mockClientListGenerator, nextClient ()).WillOnce (Return (&mockViewportMembers[0]));
+    EXPECT_CALL (mockViewportMembers[0], isDesktopOrDock ()).WillOnce (Return (true));
+    EXPECT_CALL (mockClientListGenerator, nextClient ()).WillOnce (ReturnNull ());
+
+    compiz::expo::activeViewportsForMembers (mockClientListGenerator,
+					     CompPoint (1, 1),
+					     vpSize,
+					     screenSize,
+					     activeStates);
+
+    ASSERT_EQ (activeStates.size (), vpSize.width () * vpSize.height ());
+    EXPECT_EQ (activeStates[0], false);
+    EXPECT_EQ (activeStates[1], false);
+    EXPECT_EQ (activeStates[2], false);
+    EXPECT_EQ (activeStates[3], false);
+}
+
+TEST_F (ExpoWindowsOnViewportTest, TestGrabbedWindowUsesCursorPosition)
+{
+    MockViewportMemberWindow mockViewportMembers[1];
+    InSequence s;
+
+    EXPECT_CALL (mockClientListGenerator, nextClient ()).WillOnce (Return (&mockViewportMembers[0]));
+    EXPECT_CALL (mockViewportMembers[0], isDesktopOrDock ()).WillOnce (Return (false));
+    EXPECT_CALL (mockViewportMembers[0], dragged ()).WillOnce (Return (true));
+    EXPECT_CALL (mockClientListGenerator, nextClient ()).WillOnce (ReturnNull ());
+
+    compiz::expo::activeViewportsForMembers (mockClientListGenerator,
+					     CompPoint (screenSize.width () * 1.5,
+							screenSize.height () * 1.5),
+					     vpSize,
+					     screenSize,
+					     activeStates);
+
+    ASSERT_EQ (activeStates.size (), vpSize.width () * vpSize.height ());
+    EXPECT_EQ (activeStates[0], false);
+    EXPECT_EQ (activeStates[1], false);
+    EXPECT_EQ (activeStates[2], false);
+    EXPECT_EQ (activeStates[3], true); // 2,2 has the cursor of a dragged window
+}
+
+TEST_F (ExpoWindowsOnViewportTest, TestUngrabbedWindowUsesGeometry)
+{
+    MockViewportMemberWindow mockViewportMembers[1];
+    InSequence s;
+
+    compiz::window::Geometry vpMemberGeometry1 (screenSize.width () * 1.1,
+						screenSize.height () * 1.1,
+						screenSize.width () / 2,
+						screenSize.height () / 2,
+						0);
+
+    EXPECT_CALL (mockClientListGenerator, nextClient ()).WillOnce (Return (&mockViewportMembers[0]));
+    EXPECT_CALL (mockViewportMembers[0], isDesktopOrDock ()).WillOnce (Return (false));
+    EXPECT_CALL (mockViewportMembers[0], dragged ()).WillOnce (Return (false));
+    EXPECT_CALL (mockViewportMembers[0], absoluteGeometry ()).WillOnce (ReturnRef (vpMemberGeometry1));
+    EXPECT_CALL (mockClientListGenerator, nextClient ()).WillOnce (ReturnNull ());
+
+    compiz::expo::activeViewportsForMembers (mockClientListGenerator,
+					     CompPoint (screenSize.width () * 1.5,
+							screenSize.height () * 1.5),
+					     vpSize,
+					     screenSize,
+					     activeStates);
+
+    ASSERT_EQ (activeStates.size (), vpSize.width () * vpSize.height ());
+    EXPECT_EQ (activeStates[0], false);
+    EXPECT_EQ (activeStates[1], false);
+    EXPECT_EQ (activeStates[2], false);
+    EXPECT_EQ (activeStates[3], true); // 2,2 has a window on it
+}
Index: ubuntu/plugins/expo/src/client-list-generator.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ ubuntu/plugins/expo/src/client-list-generator.h	2012-09-12 22:20:43.304760606 +0800
@@ -0,0 +1,45 @@
+/*
+ * Copyright © 2012 Canonical Ltd.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of
+ * Canonical Ltd. not be used in advertising or publicity pertaining to
+ * distribution of the software without specific, written prior permission.
+ * Canonical Ltd. makes no representations about the suitability of this
+ * software for any purpose. It is provided "as is" without express or
+ * implied warranty.
+ *
+ * CANONICAL, LTD. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN
+ * NO EVENT SHALL CANONICAL, LTD. BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
+ * OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
+ * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
+ * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Authored by: Sam Spilsbury <sam.spilsbury@canonical.com>
+ */
+#ifndef _COMPIZ_EXPO_CLIENT_LIST_GENERATOR_H
+#define _COMPIZ_EXPO_CLIENT_LIST_GENERATOR_H
+
+namespace compiz
+{
+    namespace expo
+    {
+	class ViewportMemberWindow;
+
+	class ClientListGenerator
+	{
+	    public:
+
+		virtual ~ClientListGenerator () {};
+		virtual ViewportMemberWindow * nextClient () = 0;
+	};
+    }
+}
+#endif
+
+
Index: ubuntu/plugins/expo/src/viewport-member-window.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ ubuntu/plugins/expo/src/viewport-member-window.h	2012-09-12 22:20:43.304760606 +0800
@@ -0,0 +1,46 @@
+/*
+ * Copyright © 2012 Canonical Ltd.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of
+ * Canonical Ltd. not be used in advertising or publicity pertaining to
+ * distribution of the software without specific, written prior permission.
+ * Canonical Ltd. makes no representations about the suitability of this
+ * software for any purpose. It is provided "as is" without express or
+ * implied warranty.
+ *
+ * CANONICAL, LTD. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN
+ * NO EVENT SHALL CANONICAL, LTD. BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
+ * OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
+ * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
+ * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Authored by: Sam Spilsbury <sam.spilsbury@canonical.com>
+ */
+#ifndef _COMPIZ_EXPO_VIEWPORT_MEMBER_WINDOW_H
+#define _COMPIZ_EXPO_VIEWPORT_MEMBER_WINDOW_H
+
+#include <core/windowgeometry.h>
+
+namespace compiz
+{
+    namespace expo
+    {
+	class ViewportMemberWindow
+	{
+	    public:
+
+		virtual ~ViewportMemberWindow () {};
+		virtual const compiz::window::Geometry & absoluteGeometry () const = 0;
+		virtual bool dragged () const = 0;
+		virtual bool isDesktopOrDock () const = 0;
+	};
+    }
+}
+
+#endif
